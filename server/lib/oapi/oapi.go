// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package oapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// Defines values for ClickMouseRequestButton.
const (
	Back    ClickMouseRequestButton = "back"
	Forward ClickMouseRequestButton = "forward"
	Left    ClickMouseRequestButton = "left"
	Middle  ClickMouseRequestButton = "middle"
	Right   ClickMouseRequestButton = "right"
)

// Defines values for ClickMouseRequestClickType.
const (
	Click ClickMouseRequestClickType = "click"
	Down  ClickMouseRequestClickType = "down"
	Up    ClickMouseRequestClickType = "up"
)

// ClickMouseRequest defines model for ClickMouseRequest.
type ClickMouseRequest struct {
	// Button Mouse button to interact with
	Button *ClickMouseRequestButton `json:"button,omitempty"`

	// ClickType Type of click action
	ClickType *ClickMouseRequestClickType `json:"click_type,omitempty"`

	// HoldKeys Modifier keys to hold during the click
	HoldKeys *[]string `json:"hold_keys,omitempty"`

	// NumClicks Number of times to repeat the click
	NumClicks *int `json:"num_clicks,omitempty"`

	// X X coordinate of the click position
	X int `json:"x"`

	// Y Y coordinate of the click position
	Y int `json:"y"`
}

// ClickMouseRequestButton Mouse button to interact with
type ClickMouseRequestButton string

// ClickMouseRequestClickType Type of click action
type ClickMouseRequestClickType string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// MoveMouseRequest defines model for MoveMouseRequest.
type MoveMouseRequest struct {
	// HoldKeys Modifier keys to hold during the move
	HoldKeys *[]string `json:"hold_keys,omitempty"`

	// X X coordinate to move the cursor to
	X int `json:"x"`

	// Y Y coordinate to move the cursor to
	Y int `json:"y"`
}

// PasteClipboardRequest defines model for PasteClipboardRequest.
type PasteClipboardRequest struct {
    // Text text to paste
    Text string `json:"text"`
}

// RecorderInfo defines model for RecorderInfo.
type RecorderInfo struct {
	// FinishedAt Timestamp when recording finished
	FinishedAt  *time.Time `json:"finished_at"`
	Id          string     `json:"id"`
	IsRecording bool       `json:"isRecording"`

	// StartedAt Timestamp when recording started
	StartedAt *time.Time `json:"started_at"`
}

// StartRecordingRequest defines model for StartRecordingRequest.
type StartRecordingRequest struct {
	// Framerate Recording framerate in fps (overrides server default)
	Framerate *int `json:"framerate,omitempty"`

	// Id Optional identifier for the recording session. Alphanumeric or hyphen.
	Id *string `json:"id,omitempty"`

	// MaxDurationInSeconds Maximum recording duration in seconds (overrides server default)
	MaxDurationInSeconds *int `json:"maxDurationInSeconds,omitempty"`

	// MaxFileSizeInMB Maximum file size in MB (overrides server default)
	MaxFileSizeInMB *int `json:"maxFileSizeInMB,omitempty"`
}

// StopRecordingRequest defines model for StopRecordingRequest.
type StopRecordingRequest struct {
	// ForceStop Immediately stop without graceful shutdown. This may result in a corrupted video file.
	ForceStop *bool `json:"forceStop,omitempty"`

	// Id Identifier of the recorder to stop. Alphanumeric or hyphen.
	Id *string `json:"id,omitempty"`
}

// BadRequestError defines model for BadRequestError.
type BadRequestError = Error

// ConflictError defines model for ConflictError.
type ConflictError = Error

// InternalError defines model for InternalError.
type InternalError = Error

// NotFoundError defines model for NotFoundError.
type NotFoundError = Error

// DownloadRecordingParams defines parameters for DownloadRecording.
type DownloadRecordingParams struct {
	// Id Optional recorder identifier. When omitted, the server uses the default recorder.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// ClickMouseJSONRequestBody defines body for ClickMouse for application/json ContentType.
type ClickMouseJSONRequestBody = ClickMouseRequest

// MoveMouseJSONRequestBody defines body for MoveMouse for application/json ContentType.
type MoveMouseJSONRequestBody = MoveMouseRequest

// PasteClipboardJSONRequestBody defines body for PasteClipboard for application/json ContentType.
type PasteClipboardJSONRequestBody = PasteClipboardRequest

// StartRecordingJSONRequestBody defines body for StartRecording for application/json ContentType.
type StartRecordingJSONRequestBody = StartRecordingRequest

// StopRecordingJSONRequestBody defines body for StopRecording for application/json ContentType.
type StopRecordingJSONRequestBody = StopRecordingRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ClickMouseWithBody request with any body
	ClickMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClickMouse(ctx context.Context, body ClickMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveMouseWithBody request with any body
	MoveMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveMouse(ctx context.Context, body MoveMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadRecording request
	DownloadRecording(ctx context.Context, params *DownloadRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRecorders request
	ListRecorders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartRecordingWithBody request with any body
	StartRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartRecording(ctx context.Context, body StartRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopRecordingWithBody request with any body
	StopRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopRecording(ctx context.Context, body StopRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasteClipboardWithBody request with any body
	PasteClipboardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
	// PasteClipboard request
	PasteClipboard(ctx context.Context, body PasteClipboardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ClickMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClickMouseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClickMouse(ctx context.Context, body ClickMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClickMouseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveMouseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveMouse(ctx context.Context, body MoveMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveMouseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadRecording(ctx context.Context, params *DownloadRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadRecordingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRecorders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRecordersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartRecordingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartRecording(ctx context.Context, body StartRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartRecordingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopRecordingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopRecording(ctx context.Context, body StopRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopRecordingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// PasteClipboardWithBody sends a PasteClipboard request with arbitrary body.
func (c *Client) PasteClipboardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
    req, err := NewPasteClipboardRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

// PasteClipboard sends a PasteClipboard request with application/json.
func (c *Client) PasteClipboard(ctx context.Context, body PasteClipboardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
    req, err := NewPasteClipboardRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

// NewClickMouseRequest calls the generic ClickMouse builder with application/json body
func NewClickMouseRequest(server string, body ClickMouseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClickMouseRequestWithBody(server, "application/json", bodyReader)
}

// NewClickMouseRequestWithBody generates requests for ClickMouse with any type of body
func NewClickMouseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/click_mouse")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMoveMouseRequest calls the generic MoveMouse builder with application/json body
func NewMoveMouseRequest(server string, body MoveMouseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveMouseRequestWithBody(server, "application/json", bodyReader)
}

// NewMoveMouseRequestWithBody generates requests for MoveMouse with any type of body
func NewMoveMouseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/move_mouse")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadRecordingRequest generates requests for DownloadRecording
func NewDownloadRecordingRequest(server string, params *DownloadRecordingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRecordersRequest generates requests for ListRecorders
func NewListRecordersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartRecordingRequest calls the generic StartRecording builder with application/json body
func NewStartRecordingRequest(server string, body StartRecordingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartRecordingRequestWithBody(server, "application/json", bodyReader)
}

// NewStartRecordingRequestWithBody generates requests for StartRecording with any type of body
func NewStartRecordingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopRecordingRequest calls the generic StopRecording builder with application/json body
func NewStopRecordingRequest(server string, body StopRecordingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopRecordingRequestWithBody(server, "application/json", bodyReader)
}

// NewStopRecordingRequestWithBody generates requests for StopRecording with any type of body
func NewStopRecordingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasteClipboardRequest calls the generic PasteClipboard builder with application/json body.
func NewPasteClipboardRequest(server string, body PasteClipboardJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewPasteClipboardRequestWithBody(server, "application/json", bodyReader)
}

// NewPasteClipboardRequestWithBody generates requests for PasteClipboard with any type of body.
func NewPasteClipboardRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }
    operationPath := fmt.Sprintf("/computer/paste")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }
    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }
    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }
    req.Header.Add("Content-Type", contentType)
    return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ClickMouseWithBodyWithResponse request with any body
	ClickMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClickMouseResponse, error)

	ClickMouseWithResponse(ctx context.Context, body ClickMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*ClickMouseResponse, error)

	// MoveMouseWithBodyWithResponse request with any body
	MoveMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveMouseResponse, error)

	MoveMouseWithResponse(ctx context.Context, body MoveMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveMouseResponse, error)

	// DownloadRecordingWithResponse request
	DownloadRecordingWithResponse(ctx context.Context, params *DownloadRecordingParams, reqEditors ...RequestEditorFn) (*DownloadRecordingResponse, error)

	// ListRecordersWithResponse request
	ListRecordersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRecordersResponse, error)

	// StartRecordingWithBodyWithResponse request with any body
	StartRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartRecordingResponse, error)

	StartRecordingWithResponse(ctx context.Context, body StartRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*StartRecordingResponse, error)

	// StopRecordingWithBodyWithResponse request with any body
	StopRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopRecordingResponse, error)

	StopRecordingWithResponse(ctx context.Context, body StopRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*StopRecordingResponse, error)
}

type ClickMouseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ClickMouseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClickMouseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveMouseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r MoveMouseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveMouseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecordersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RecorderInfo
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListRecordersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecordersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON409      *ConflictError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r StartRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r StopRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ClickMouseWithBodyWithResponse request with arbitrary body returning *ClickMouseResponse
func (c *ClientWithResponses) ClickMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClickMouseResponse, error) {
	rsp, err := c.ClickMouseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClickMouseResponse(rsp)
}

func (c *ClientWithResponses) ClickMouseWithResponse(ctx context.Context, body ClickMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*ClickMouseResponse, error) {
	rsp, err := c.ClickMouse(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClickMouseResponse(rsp)
}

// MoveMouseWithBodyWithResponse request with arbitrary body returning *MoveMouseResponse
func (c *ClientWithResponses) MoveMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveMouseResponse, error) {
	rsp, err := c.MoveMouseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveMouseResponse(rsp)
}

func (c *ClientWithResponses) MoveMouseWithResponse(ctx context.Context, body MoveMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveMouseResponse, error) {
	rsp, err := c.MoveMouse(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveMouseResponse(rsp)
}

// DownloadRecordingWithResponse request returning *DownloadRecordingResponse
func (c *ClientWithResponses) DownloadRecordingWithResponse(ctx context.Context, params *DownloadRecordingParams, reqEditors ...RequestEditorFn) (*DownloadRecordingResponse, error) {
	rsp, err := c.DownloadRecording(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadRecordingResponse(rsp)
}

// ListRecordersWithResponse request returning *ListRecordersResponse
func (c *ClientWithResponses) ListRecordersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRecordersResponse, error) {
	rsp, err := c.ListRecorders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRecordersResponse(rsp)
}

// StartRecordingWithBodyWithResponse request with arbitrary body returning *StartRecordingResponse
func (c *ClientWithResponses) StartRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartRecordingResponse, error) {
	rsp, err := c.StartRecordingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartRecordingResponse(rsp)
}

func (c *ClientWithResponses) StartRecordingWithResponse(ctx context.Context, body StartRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*StartRecordingResponse, error) {
	rsp, err := c.StartRecording(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartRecordingResponse(rsp)
}

// StopRecordingWithBodyWithResponse request with arbitrary body returning *StopRecordingResponse
func (c *ClientWithResponses) StopRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopRecordingResponse, error) {
	rsp, err := c.StopRecordingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopRecordingResponse(rsp)
}

func (c *ClientWithResponses) StopRecordingWithResponse(ctx context.Context, body StopRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*StopRecordingResponse, error) {
	rsp, err := c.StopRecording(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopRecordingResponse(rsp)
}

// ParseClickMouseResponse parses an HTTP response from a ClickMouseWithResponse call
func ParseClickMouseResponse(rsp *http.Response) (*ClickMouseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClickMouseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMoveMouseResponse parses an HTTP response from a MoveMouseWithResponse call
func ParseMoveMouseResponse(rsp *http.Response) (*MoveMouseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveMouseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadRecordingResponse parses an HTTP response from a DownloadRecordingWithResponse call
func ParseDownloadRecordingResponse(rsp *http.Response) (*DownloadRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRecordersResponse parses an HTTP response from a ListRecordersWithResponse call
func ParseListRecordersResponse(rsp *http.Response) (*ListRecordersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecordersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RecorderInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartRecordingResponse parses an HTTP response from a StartRecordingWithResponse call
func ParseStartRecordingResponse(rsp *http.Response) (*StartRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopRecordingResponse parses an HTTP response from a StopRecordingWithResponse call
func ParseStopRecordingResponse(rsp *http.Response) (*StopRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Simulate a mouse click action on the host computer
	// (POST /computer/click_mouse)
	ClickMouse(w http.ResponseWriter, r *http.Request)
	// Move the mouse cursor to the specified coordinates on the host computer
	// (POST /computer/move_mouse)
	MoveMouse(w http.ResponseWriter, r *http.Request)
	// Download the most recently recorded video file
	// (GET /recording/download)
	DownloadRecording(w http.ResponseWriter, r *http.Request, params DownloadRecordingParams)
	// List all recorders
	// (GET /recording/list)
	ListRecorders(w http.ResponseWriter, r *http.Request)
	// Start a screen recording. Only one recording per ID can be registered at a time.
	// (POST /recording/start)
	StartRecording(w http.ResponseWriter, r *http.Request)
	// Stop the recording
	// (POST /recording/stop)
	StopRecording(w http.ResponseWriter, r *http.Request)
	// PasteClipboard(w http.ResponseWriter, r *http.Request)
	PasteClipboard(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Simulate a mouse click action on the host computer
// (POST /computer/click_mouse)
func (_ Unimplemented) ClickMouse(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Move the mouse cursor to the specified coordinates on the host computer
// (POST /computer/move_mouse)
func (_ Unimplemented) MoveMouse(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Download the most recently recorded video file
// (GET /recording/download)
func (_ Unimplemented) DownloadRecording(w http.ResponseWriter, r *http.Request, params DownloadRecordingParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all recorders
// (GET /recording/list)
func (_ Unimplemented) ListRecorders(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Start a screen recording. Only one recording per ID can be registered at a time.
// (POST /recording/start)
func (_ Unimplemented) StartRecording(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stop the recording
// (POST /recording/stop)
func (_ Unimplemented) StopRecording(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ClickMouse operation middleware
func (siw *ServerInterfaceWrapper) ClickMouse(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ClickMouse(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// MoveMouse operation middleware
func (siw *ServerInterfaceWrapper) MoveMouse(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MoveMouse(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PasteClipboard operation middleware
func (siw *ServerInterfaceWrapper) PasteClipboard(w http.ResponseWriter, r *http.Request) {
    handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        siw.Handler.PasteClipboard(w, r)
    }))
    for _, middleware := range siw.HandlerMiddlewares {
        handler = middleware(handler)
    }
    handler.ServeHTTP(w, r)
}

// DownloadRecording operation middleware
func (siw *ServerInterfaceWrapper) DownloadRecording(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadRecordingParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadRecording(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListRecorders operation middleware
func (siw *ServerInterfaceWrapper) ListRecorders(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRecorders(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StartRecording operation middleware
func (siw *ServerInterfaceWrapper) StartRecording(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartRecording(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StopRecording operation middleware
func (siw *ServerInterfaceWrapper) StopRecording(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StopRecording(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PasteClipboard operation middleware
func (siw *ServerInterfaceWrapper) PasteClipboard(w http.ResponseWriter, r *http.Request) {
    handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        siw.Handler.PasteClipboard(w, r)
    }))
    for _, mw := range siw.HandlerMiddlewares {
        handler = mw(handler)
    }
    handler.ServeHTTP(w, r)
}


type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/click_mouse", wrapper.ClickMouse)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/move_mouse", wrapper.MoveMouse)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/paste", wrapper.PasteClipboard)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recording/download", wrapper.DownloadRecording)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recording/list", wrapper.ListRecorders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/recording/start", wrapper.StartRecording)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/recording/stop", wrapper.StopRecording)
	})

	return r
}

type BadRequestErrorJSONResponse Error

type ConflictErrorJSONResponse Error

type InternalErrorJSONResponse Error

type NotFoundErrorJSONResponse Error

type ClickMouseRequestObject struct {
	Body *ClickMouseJSONRequestBody
}

type ClickMouseResponseObject interface {
	VisitClickMouseResponse(w http.ResponseWriter) error
}

type ClickMouse200Response struct {
}

func (response ClickMouse200Response) VisitClickMouseResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type ClickMouse400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ClickMouse400JSONResponse) VisitClickMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ClickMouse500JSONResponse struct{ InternalErrorJSONResponse }

func (response ClickMouse500JSONResponse) VisitClickMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type MoveMouseRequestObject struct {
	Body *MoveMouseJSONRequestBody
}

type MoveMouseResponseObject interface {
	VisitMoveMouseResponse(w http.ResponseWriter) error
}

type MoveMouse200Response struct {
}

func (response MoveMouse200Response) VisitMoveMouseResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type MoveMouse400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response MoveMouse400JSONResponse) VisitMoveMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type MoveMouse500JSONResponse struct{ InternalErrorJSONResponse }

func (response MoveMouse500JSONResponse) VisitMoveMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DownloadRecordingRequestObject struct {
	Params DownloadRecordingParams
}

type DownloadRecordingResponseObject interface {
	VisitDownloadRecordingResponse(w http.ResponseWriter) error
}

type DownloadRecording200ResponseHeaders struct {
	XRecordingFinishedAt string
	XRecordingStartedAt  string
}

type DownloadRecording200Videomp4Response struct {
	Body          io.Reader
	Headers       DownloadRecording200ResponseHeaders
	ContentLength int64
}

func (response DownloadRecording200Videomp4Response) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "video/mp4")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("X-Recording-Finished-At", fmt.Sprint(response.Headers.XRecordingFinishedAt))
	w.Header().Set("X-Recording-Started-At", fmt.Sprint(response.Headers.XRecordingStartedAt))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DownloadRecording202ResponseHeaders struct {
	RetryAfter int
}

type DownloadRecording202Response struct {
	Headers DownloadRecording202ResponseHeaders
}

func (response DownloadRecording202Response) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(202)
	return nil
}

type DownloadRecording400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DownloadRecording400JSONResponse) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DownloadRecording404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DownloadRecording404JSONResponse) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DownloadRecording500JSONResponse struct{ InternalErrorJSONResponse }

func (response DownloadRecording500JSONResponse) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListRecordersRequestObject struct {
}

type ListRecordersResponseObject interface {
	VisitListRecordersResponse(w http.ResponseWriter) error
}

type ListRecorders200JSONResponse []RecorderInfo

func (response ListRecorders200JSONResponse) VisitListRecordersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListRecorders500JSONResponse struct{ InternalErrorJSONResponse }

func (response ListRecorders500JSONResponse) VisitListRecordersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type StartRecordingRequestObject struct {
	Body *StartRecordingJSONRequestBody
}

type StartRecordingResponseObject interface {
	VisitStartRecordingResponse(w http.ResponseWriter) error
}

type StartRecording201Response struct {
}

func (response StartRecording201Response) VisitStartRecordingResponse(w http.ResponseWriter) error {
	w.WriteHeader(201)
	return nil
}

type StartRecording400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response StartRecording400JSONResponse) VisitStartRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type StartRecording409JSONResponse struct{ ConflictErrorJSONResponse }

func (response StartRecording409JSONResponse) VisitStartRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type StartRecording500JSONResponse struct{ InternalErrorJSONResponse }

func (response StartRecording500JSONResponse) VisitStartRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type StopRecordingRequestObject struct {
	Body *StopRecordingJSONRequestBody
}

type StopRecordingResponseObject interface {
	VisitStopRecordingResponse(w http.ResponseWriter) error
}

type StopRecording200Response struct {
}

func (response StopRecording200Response) VisitStopRecordingResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type StopRecording400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response StopRecording400JSONResponse) VisitStopRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type StopRecording500JSONResponse struct{ InternalErrorJSONResponse }

func (response StopRecording500JSONResponse) VisitStopRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Simulate a mouse click action on the host computer
	// (POST /computer/click_mouse)
	ClickMouse(ctx context.Context, request ClickMouseRequestObject) (ClickMouseResponseObject, error)
	// Move the mouse cursor to the specified coordinates on the host computer
	// (POST /computer/move_mouse)
	MoveMouse(ctx context.Context, request MoveMouseRequestObject) (MoveMouseResponseObject, error)
	// Download the most recently recorded video file
	// (GET /recording/download)
	DownloadRecording(ctx context.Context, request DownloadRecordingRequestObject) (DownloadRecordingResponseObject, error)
	// List all recorders
	// (GET /recording/list)
	ListRecorders(ctx context.Context, request ListRecordersRequestObject) (ListRecordersResponseObject, error)
	// Start a screen recording. Only one recording per ID can be registered at a time.
	// (POST /recording/start)
	StartRecording(ctx context.Context, request StartRecordingRequestObject) (StartRecordingResponseObject, error)
	// Stop the recording
	// (POST /recording/stop)
	StopRecording(ctx context.Context, request StopRecordingRequestObject) (StopRecordingResponseObject, error)

	// Paste text via system clipboard and simulate paste
	// (POST /computer/paste)
	PasteClipboard(ctx context.Context, request PasteClipboardRequestObject) (PasteClipboardResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ClickMouse operation middleware
func (sh *strictHandler) ClickMouse(w http.ResponseWriter, r *http.Request) {
	var request ClickMouseRequestObject

	var body ClickMouseJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ClickMouse(ctx, request.(ClickMouseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ClickMouse")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ClickMouseResponseObject); ok {
		if err := validResponse.VisitClickMouseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// MoveMouse operation middleware
func (sh *strictHandler) MoveMouse(w http.ResponseWriter, r *http.Request) {
	var request MoveMouseRequestObject

	var body MoveMouseJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.MoveMouse(ctx, request.(MoveMouseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "MoveMouse")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(MoveMouseResponseObject); ok {
		if err := validResponse.VisitMoveMouseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DownloadRecording operation middleware
func (sh *strictHandler) DownloadRecording(w http.ResponseWriter, r *http.Request, params DownloadRecordingParams) {
	var request DownloadRecordingRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DownloadRecording(ctx, request.(DownloadRecordingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DownloadRecording")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DownloadRecordingResponseObject); ok {
		if err := validResponse.VisitDownloadRecordingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListRecorders operation middleware
func (sh *strictHandler) ListRecorders(w http.ResponseWriter, r *http.Request) {
	var request ListRecordersRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListRecorders(ctx, request.(ListRecordersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListRecorders")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListRecordersResponseObject); ok {
		if err := validResponse.VisitListRecordersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StartRecording operation middleware
func (sh *strictHandler) StartRecording(w http.ResponseWriter, r *http.Request) {
	var request StartRecordingRequestObject

	var body StartRecordingJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StartRecording(ctx, request.(StartRecordingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StartRecording")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StartRecordingResponseObject); ok {
		if err := validResponse.VisitStartRecordingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StopRecording operation middleware
func (sh *strictHandler) StopRecording(w http.ResponseWriter, r *http.Request) {
	var request StopRecordingRequestObject

	var body StopRecordingJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StopRecording(ctx, request.(StopRecordingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StopRecording")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StopRecordingResponseObject); ok {
		if err := validResponse.VisitStopRecordingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PasteClipboard operation middleware
func (sh *strictHandler) PasteClipboard(w http.ResponseWriter, r *http.Request) {
    var request PasteClipboardRequestObject
    var body PasteClipboardJSONRequestBody
    if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
        sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
        return
    }
    request.Body = &body

    handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, req interface{}) (interface{}, error) {
        return sh.ssi.PasteClipboard(ctx, req.(PasteClipboardRequestObject))
    }
    for _, mw := range sh.middlewares {
        handler = mw(handler, "PasteClipboard")
    }

    resp, err := handler(r.Context(), w, r, request)
    if err != nil {
        sh.options.ResponseErrorHandlerFunc(w, r, err)
    } else if okResp, ok := resp.(PasteClipboardResponseObject); ok {
        if err := okResp.VisitPasteClipboardResponse(w); err != nil {
            sh.options.ResponseErrorHandlerFunc(w, r, err)
        }
    } else if resp != nil {
        sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", resp))
    }
}


// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/8RYW28buxH+KwR7Hlp0dXHsFoje7KQuhNbnHNgBmjZIDWo5q2XCJZkh1/bG0H8/GHIl",
	"7Vpr2bGd5MleXmaGc/nmG93y3FbOGjDB89ktR/DOGg/x40TIc/hSgw//QLRIS7k1AUygf4VzWuUiKGsm",
	"n7w1tObzEipB//2CUPAZ/9NkK3+Sdv0kSVutVhmX4HNUjoTwGSlkrUa+yvgbawqt8h+lfa2OVM9NADRC",
	"/yDVa3XsAvAKkLUHM/6rDae2NvIH2fGrDSzq47TXHidpb7TKP5/Z2sM6PmSAlIouCv07WgcYFOVNIbSH",
	"jLvO0i1f1CEkC/sKo0iWdlmwTJEjRB7YtQolzziYuuKzD1xDEXjGUS1L+lspKTXwjC9E/plnvLB4LVDy",
	"jxkPjQM+4z6gMktyYU6mX6blu+rfNQ6YLVg8w0Qel7dapb2mz9rxVsyggtJqefkZGj/0PKkKBchom95H",
	"Z5ms6SoLJSTFPOMqQBXv70hvFwSiaOjb1NVlvNWqK0StA58d7ISyrhaA9LigKojKERyI0NPbSie3LyFm",
	"3M3uK96z3FqUyogQvbURwJz1qvXZrqRmV9J/nyJplXGEL7VCkBSUG06it4Gwi0+QinZTJP3cq8B7sYQB",
	"796RvD44JPvMXsEz8v85OVLZK/imFHkohMFGmcn7NXqLLNgnhfCxkh4dwnPILUrAuSnsbiQLZZQvQV6K",
	"MFDLlOZBVI5dl2AYRknkw/WthBMV3eVSBBhRYXCqKK3FQgOfBaxhoMCVHHS78udrHZ39hbUahKEDPggM",
	"32pte+mJxt5xtCI5XTuHfH5BGjdHnpbfBYoKUIQBjD3fBmJ9iCnDCufZn+0VICoJnvnU+Fo8+wthvLhR",
	"FeHw36cE+CZ9HAylaQpQX+1vLpnOlAQTUoUVlJ8ldL0N3itrxuxYu1KYugJUObPIysaVYMY8404Eas58",
	"xv//QYy+Ho/+Nx29Hn386y98IFUqcfO2xtiT5+YCcmvkUMmnp3XskO0l8oxP1x7wzl6HVOLmVGm4UF9h",
	"bs5O7regUBqYV19jSM5OHhmRg+l02gvKdLDkBzLNuucmmsUcSE6v+7VH75CqqgKpRADdMB+si5zC1oEt",
	"UeRQ1Jr5sg7U48fsXak8q0TDEHytA3lDsNwi1i6AZFdKgo3OGm+j3qn0oQScb/Ou7XTYghvBJhn0Qlm3",
	"62laUi2CBhUILfi/AA1oNq/EEjw7/n3OM34F6JOx0/HBeEovsQ6McIrP+OF4Oj5MlpTR9ZFJ1gFwkihV",
	"Re0wgrRNYaQ4pdSXRKc3lJEnUAIfTqxsXozF7nLSVR//CCHjQmemeTWd3sdCE/1jDpCQFyS54ygdHzJj",
	"I3Zyd05aZfxvj7nXHzIi466rSmDDZ/xCVbUmqBQs+rlHURmR5RJYaX1g66hEAdsYUV9+KEQbUvOdIrRD",
	"mp4XoJZh0Mt+bnDO1pyn6toVbFzzDnIqe9khSn5PxDZNYEJQpK2IWLKEgXi9bQ9s+zmVJ3XVAOj57MO9",
	"TXADPdtuOGb/IeZhKxUCyCzZnjC/9jQwlLAG/811QiZFgr/UgA3REVFF1Ceesc2JbwGvj8Px7+RfBN9J",
	"5Y76ibehRwtlRDTmruid8bZDRVQcH0sQMnrulr8fbXZHpy1jHB3vZW62SOStTynWdHPM/lkLFCYASMqN",
	"BbDz0zeHh4evxz1n7aJ515SLRAefZElLJZ9qCJnyavpqH6NTnvmgtKZ+6dAuEbzPmNMgPLCADRNLoQwj",
	"IMO+u88hYDM6LmhjR8FFvVyCp8Z7LVSIA2yXGC2gsEgPDdikItg+Yh8vii96KmgcTY8evtf/ueYloGZd",
	"8i3c+FiLYIJu1kXZZSd3EUWrBPuDaPJv5cN63vL8wTLc3wY20+m+ftCb7nYG1916JQspt3Fj5Uu4NEoV",
	"WnfF9t0WC+f+ttkfmL5T7xyeylZtB+1F6mBfia7nyWel/uuH7/V/rH0RCkSWM8F8jtAdkcfsN6MbZk0X",
	"6xwgm79luTCEbwhL5QMgSCZIBCHIeDfKaYq4L8idWeW7xXhgHhoM8XR/iK1zP5uv0oDVaz/xIX8EAAD/",
	"/32oWkJgGAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

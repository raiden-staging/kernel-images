// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package oapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ClickMouseRequestButton.
const (
	ClickMouseRequestButtonBack    ClickMouseRequestButton = "back"
	ClickMouseRequestButtonForward ClickMouseRequestButton = "forward"
	ClickMouseRequestButtonLeft    ClickMouseRequestButton = "left"
	ClickMouseRequestButtonMiddle  ClickMouseRequestButton = "middle"
	ClickMouseRequestButtonRight   ClickMouseRequestButton = "right"
)

// Defines values for ClickMouseRequestClickType.
const (
	Click ClickMouseRequestClickType = "click"
	Down  ClickMouseRequestClickType = "down"
	Up    ClickMouseRequestClickType = "up"
)

// Defines values for DragMouseRequestButton.
const (
	DragMouseRequestButtonLeft   DragMouseRequestButton = "left"
	DragMouseRequestButtonMiddle DragMouseRequestButton = "middle"
	DragMouseRequestButtonRight  DragMouseRequestButton = "right"
)

// Defines values for FileSystemEventType.
const (
	CREATE FileSystemEventType = "CREATE"
	DELETE FileSystemEventType = "DELETE"
	RENAME FileSystemEventType = "RENAME"
	WRITE  FileSystemEventType = "WRITE"
)

// Defines values for PatchDisplayRequestRefreshRate.
const (
	N10 PatchDisplayRequestRefreshRate = 10
	N25 PatchDisplayRequestRefreshRate = 25
	N30 PatchDisplayRequestRefreshRate = 30
	N60 PatchDisplayRequestRefreshRate = 60
)

// Defines values for ProcessKillRequestSignal.
const (
	HUP  ProcessKillRequestSignal = "HUP"
	INT  ProcessKillRequestSignal = "INT"
	KILL ProcessKillRequestSignal = "KILL"
	TERM ProcessKillRequestSignal = "TERM"
)

// Defines values for ProcessStatusState.
const (
	Exited  ProcessStatusState = "exited"
	Running ProcessStatusState = "running"
)

// Defines values for ProcessStreamEventEvent.
const (
	Exit ProcessStreamEventEvent = "exit"
)

// Defines values for ProcessStreamEventStream.
const (
	Stderr ProcessStreamEventStream = "stderr"
	Stdout ProcessStreamEventStream = "stdout"
)

// Defines values for LogsStreamParamsSource.
const (
	Path       LogsStreamParamsSource = "path"
	Supervisor LogsStreamParamsSource = "supervisor"
)

// BenchmarkResults Performance benchmark results.
type BenchmarkResults struct {
	// ElapsedSeconds Actual elapsed time in seconds for all benchmarks to complete
	ElapsedSeconds *float32 `json:"elapsed_seconds,omitempty"`

	// Errors Errors encountered during benchmarking.
	Errors *[]string `json:"errors,omitempty"`

	// Results Results from individual benchmark components.
	Results *ComponentResults `json:"results,omitempty"`

	// StartupTiming Container startup timing metrics
	StartupTiming *StartupTimingResults `json:"startup_timing,omitempty"`
	System        *SystemInfo           `json:"system,omitempty"`

	// Timestamp When the benchmark was run
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// BitrateMetrics defines model for BitrateMetrics.
type BitrateMetrics struct {
	// Audio Audio bitrate in kbps
	Audio *float32 `json:"audio,omitempty"`

	// Total Total bitrate in kbps
	Total *float32 `json:"total,omitempty"`

	// Video Video bitrate in kbps
	Video *float32 `json:"video,omitempty"`
}

// CDPEndpointResults Results for a specific CDP endpoint (proxied or direct)
type CDPEndpointResults struct {
	// EndpointUrl CDP endpoint URL
	EndpointUrl string `json:"endpoint_url"`

	// Scenarios Per-scenario results for this endpoint
	Scenarios []CDPScenarioResult `json:"scenarios"`

	// SessionFailures Sessions that failed during setup (create/attach/navigation)
	SessionFailures *int `json:"session_failures,omitempty"`

	// SessionsStarted Successfully prepared CDP sessions (per-endpoint)
	SessionsStarted *int `json:"sessions_started,omitempty"`

	// TotalThroughputOpsPerSec Total operations per second across all scenarios
	TotalThroughputOpsPerSec float32 `json:"total_throughput_ops_per_sec"`
}

// CDPProxyResults CDP proxy benchmark results comparing direct vs proxied endpoints
type CDPProxyResults struct {
	// ConcurrentConnections Number of concurrent connections used in benchmark
	ConcurrentConnections *int `json:"concurrent_connections,omitempty"`

	// DirectEndpoint Results for a specific CDP endpoint (proxied or direct)
	DirectEndpoint *CDPEndpointResults `json:"direct_endpoint,omitempty"`
	MemoryMb       *MemoryMetrics      `json:"memory_mb,omitempty"`

	// ProxiedEndpoint Results for a specific CDP endpoint (proxied or direct)
	ProxiedEndpoint *CDPEndpointResults `json:"proxied_endpoint,omitempty"`

	// ProxyOverheadPercent Performance overhead of proxy as percentage (positive = slower through proxy)
	ProxyOverheadPercent *float32 `json:"proxy_overhead_percent,omitempty"`
}

// CDPScenarioResult Results for a specific CDP test scenario
type CDPScenarioResult struct {
	// AttemptCount Total attempts issued for this scenario
	AttemptCount *int `json:"attempt_count,omitempty"`

	// Category Scenario category (e.g., Runtime, DOM, Page, Network, Performance)
	Category *string `json:"category,omitempty"`

	// Description Human-readable description of the scenario
	Description *string `json:"description,omitempty"`

	// DurationSeconds Wall-clock time spent running this scenario
	DurationSeconds *float32 `json:"duration_seconds,omitempty"`

	// ErrorSamples Sample of unique error messages encountered during benchmark
	ErrorSamples *[]string `json:"error_samples,omitempty"`

	// FailureCount Number of failed attempts for this scenario
	FailureCount *int            `json:"failure_count,omitempty"`
	LatencyMs    *LatencyMetrics `json:"latency_ms,omitempty"`

	// Name Scenario name (e.g., Runtime.evaluate, DOM.getDocument)
	Name *string `json:"name,omitempty"`

	// OperationCount Number of successful operations performed in this scenario
	OperationCount *int `json:"operation_count,omitempty"`

	// SuccessRate Success rate percentage (0-100)
	SuccessRate *float32 `json:"success_rate,omitempty"`

	// ThroughputOpsPerSec Operations per second for this scenario
	ThroughputOpsPerSec *float32 `json:"throughput_ops_per_sec,omitempty"`
}

// ClickMouseRequest defines model for ClickMouseRequest.
type ClickMouseRequest struct {
	// Button Mouse button to interact with
	Button *ClickMouseRequestButton `json:"button,omitempty"`

	// ClickType Type of click action
	ClickType *ClickMouseRequestClickType `json:"click_type,omitempty"`

	// HoldKeys Modifier keys to hold during the click
	HoldKeys *[]string `json:"hold_keys,omitempty"`

	// NumClicks Number of times to repeat the click
	NumClicks *int `json:"num_clicks,omitempty"`

	// X X coordinate of the click position
	X int `json:"x"`

	// Y Y coordinate of the click position
	Y int `json:"y"`
}

// ClickMouseRequestButton Mouse button to interact with
type ClickMouseRequestButton string

// ClickMouseRequestClickType Type of click action
type ClickMouseRequestClickType string

// CodecMetrics Codec information
type CodecMetrics struct {
	// Audio Audio codec (e.g., audio/opus)
	Audio *string `json:"audio,omitempty"`

	// Video Video codec (e.g., video/VP8)
	Video *string `json:"video,omitempty"`
}

// ComponentResults Results from individual benchmark components.
type ComponentResults struct {
	// Cdp CDP proxy benchmark results comparing direct vs proxied endpoints
	Cdp       *CDPProxyResults  `json:"cdp,omitempty"`
	Recording *RecordingResults `json:"recording,omitempty"`

	// WebrtcLiveView Comprehensive WebRTC live view benchmark results from client
	WebrtcLiveView *WebRTCLiveViewResults `json:"webrtc_live_view,omitempty"`
}

// CreateDirectoryRequest defines model for CreateDirectoryRequest.
type CreateDirectoryRequest struct {
	// Mode Optional directory mode (octal string, e.g. 755). Defaults to 755.
	Mode *string `json:"mode,omitempty"`

	// Path Absolute directory path to create.
	Path string `json:"path"`
}

// DeletePathRequest defines model for DeletePathRequest.
type DeletePathRequest struct {
	// Path Absolute path to delete.
	Path string `json:"path"`
}

// DeleteRecordingRequest defines model for DeleteRecordingRequest.
type DeleteRecordingRequest struct {
	// Id Identifier of the recording to delete. Alphanumeric or hyphen.
	Id *string `json:"id,omitempty"`
}

// DisplayConfig defines model for DisplayConfig.
type DisplayConfig struct {
	// Height Current display height in pixels
	Height *int `json:"height,omitempty"`

	// RefreshRate Current display refresh rate in Hz (may be null if not detectable)
	RefreshRate *int `json:"refresh_rate,omitempty"`

	// Width Current display width in pixels
	Width *int `json:"width,omitempty"`
}

// DragMouseRequest defines model for DragMouseRequest.
type DragMouseRequest struct {
	// Button Mouse button to drag with
	Button *DragMouseRequestButton `json:"button,omitempty"`

	// Delay Delay in milliseconds between button down and starting to move along the path.
	Delay *int `json:"delay,omitempty"`

	// HoldKeys Modifier keys to hold during the drag
	HoldKeys *[]string `json:"hold_keys,omitempty"`

	// Path Ordered list of [x, y] coordinate pairs to move through while dragging. Must contain at least 2 points.
	Path [][]int `json:"path"`

	// StepDelayMs Delay in milliseconds between relative steps while dragging (not the initial delay).
	StepDelayMs *int `json:"step_delay_ms,omitempty"`

	// StepsPerSegment Number of relative move steps per segment in the path. Minimum 1.
	StepsPerSegment *int `json:"steps_per_segment,omitempty"`
}

// DragMouseRequestButton Mouse button to drag with
type DragMouseRequestButton string

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// ExecutePlaywrightRequest Request to execute Playwright code
type ExecutePlaywrightRequest struct {
	// Code TypeScript/JavaScript code to execute. The code has access to 'page', 'context', and 'browser' variables.
	// Example: "await page.goto('https://example.com'); return await page.title();"
	Code string `json:"code"`

	// TimeoutSec Maximum execution time in seconds. Default is 60.
	TimeoutSec *int `json:"timeout_sec,omitempty"`
}

// ExecutePlaywrightResult Result of Playwright code execution
type ExecutePlaywrightResult struct {
	// Error Error message if execution failed
	Error *string `json:"error,omitempty"`

	// Result The value returned by the code (if any)
	Result interface{} `json:"result,omitempty"`

	// Stderr Standard error from the execution
	Stderr *string `json:"stderr,omitempty"`

	// Stdout Standard output from the execution
	Stdout *string `json:"stdout,omitempty"`

	// Success Whether the code executed successfully
	Success bool `json:"success"`
}

// FileInfo defines model for FileInfo.
type FileInfo struct {
	// IsDir Whether the path is a directory.
	IsDir bool `json:"is_dir"`

	// ModTime Last modification time.
	ModTime time.Time `json:"mod_time"`

	// Mode File mode bits (e.g., "drwxr-xr-x" or "-rw-r--r--").
	Mode string `json:"mode"`

	// Name Base name of the file or directory.
	Name string `json:"name"`

	// Path Absolute path.
	Path string `json:"path"`

	// SizeBytes Size in bytes. 0 for directories.
	SizeBytes int `json:"size_bytes"`
}

// FileSystemEvent Filesystem change event.
type FileSystemEvent struct {
	// IsDir Whether the affected path is a directory.
	IsDir *bool `json:"is_dir,omitempty"`

	// Name Base name of the file or directory affected.
	Name *string `json:"name,omitempty"`

	// Path Absolute path of the file or directory.
	Path string `json:"path"`

	// Type Event type.
	Type FileSystemEventType `json:"type"`
}

// FileSystemEventType Event type.
type FileSystemEventType string

// FrameMetrics Frame statistics for WebRTC video
type FrameMetrics struct {
	// Corrupted Corrupted frames
	Corrupted *int `json:"corrupted,omitempty"`

	// Decoded Frames decoded
	Decoded *int `json:"decoded,omitempty"`

	// Dropped Frames dropped
	Dropped *int `json:"dropped,omitempty"`

	// KeyFramesDecoded Key frames decoded
	KeyFramesDecoded *int `json:"key_frames_decoded,omitempty"`

	// Received Total frames received
	Received *int `json:"received,omitempty"`
}

// FrameRateMetrics defines model for FrameRateMetrics.
type FrameRateMetrics struct {
	Achieved *float32 `json:"achieved,omitempty"`
	Max      *float32 `json:"max,omitempty"`
	Min      *float32 `json:"min,omitempty"`
	Target   *float32 `json:"target,omitempty"`
}

// JitterMetrics Jitter measurements in milliseconds
type JitterMetrics struct {
	// Audio Audio jitter in ms
	Audio *float32 `json:"audio,omitempty"`

	// Video Video jitter in ms
	Video *float32 `json:"video,omitempty"`
}

// LatencyMetrics defines model for LatencyMetrics.
type LatencyMetrics struct {
	P50 *float32 `json:"p50,omitempty"`
	P95 *float32 `json:"p95,omitempty"`
	P99 *float32 `json:"p99,omitempty"`
}

// ListFiles Array of file or directory information entries.
type ListFiles = []FileInfo

// LogEvent A log entry from the application.
type LogEvent struct {
	// Message Log message text.
	Message string `json:"message"`

	// Timestamp Time the log entry was produced.
	Timestamp time.Time `json:"timestamp"`
}

// MemoryMetrics defines model for MemoryMetrics.
type MemoryMetrics struct {
	Baseline      *float32 `json:"baseline,omitempty"`
	PerConnection *float32 `json:"per_connection,omitempty"`
	PerViewer     *float32 `json:"per_viewer,omitempty"`
}

// MoveMouseRequest defines model for MoveMouseRequest.
type MoveMouseRequest struct {
	// HoldKeys Modifier keys to hold during the move
	HoldKeys *[]string `json:"hold_keys,omitempty"`

	// X X coordinate to move the cursor to
	X int `json:"x"`

	// Y Y coordinate to move the cursor to
	Y int `json:"y"`
}

// MovePathRequest defines model for MovePathRequest.
type MovePathRequest struct {
	// DestPath Absolute destination path.
	DestPath string `json:"dest_path"`

	// SrcPath Absolute source path.
	SrcPath string `json:"src_path"`
}

// NetworkMetrics Network-level metrics
type NetworkMetrics struct {
	// AvailableOutgoingBitrateKbps Available outgoing bitrate in kbps
	AvailableOutgoingBitrateKbps *float32 `json:"available_outgoing_bitrate_kbps,omitempty"`

	// BytesReceived Total bytes received
	BytesReceived *int `json:"bytes_received,omitempty"`

	// BytesSent Total bytes sent
	BytesSent *int `json:"bytes_sent,omitempty"`

	// RttMs Round-trip time in milliseconds
	RttMs *float32 `json:"rtt_ms,omitempty"`
}

// OkResponse Generic OK response.
type OkResponse struct {
	// Ok Indicates success.
	Ok bool `json:"ok"`
}

// PacketMetrics Packet statistics for WebRTC streams
type PacketMetrics struct {
	// AudioLost Total audio packets lost
	AudioLost *int `json:"audio_lost,omitempty"`

	// AudioReceived Total audio packets received
	AudioReceived *int `json:"audio_received,omitempty"`

	// LossPercent Overall packet loss percentage
	LossPercent *float32 `json:"loss_percent,omitempty"`

	// VideoLost Total video packets lost
	VideoLost *int `json:"video_lost,omitempty"`

	// VideoReceived Total video packets received
	VideoReceived *int `json:"video_received,omitempty"`
}

// PatchDisplayRequest defines model for PatchDisplayRequest.
type PatchDisplayRequest struct {
	// Height Display height in pixels
	Height *int `json:"height,omitempty"`

	// RefreshRate Display refresh rate in Hz. If omitted, uses the highest available rate for the resolution.
	RefreshRate *PatchDisplayRequestRefreshRate `json:"refresh_rate,omitempty"`

	// RequireIdle If true, refuse to resize when live view or recording/replay is active.
	RequireIdle *bool `json:"require_idle,omitempty"`

	// RestartChromium If true, restart Chromium after resolution change to ensure it adapts to new size. Default is false for headful, true for headless.
	RestartChromium *bool `json:"restart_chromium,omitempty"`

	// Width Display width in pixels
	Width *int `json:"width,omitempty"`
}

// PatchDisplayRequestRefreshRate Display refresh rate in Hz. If omitted, uses the highest available rate for the resolution.
type PatchDisplayRequestRefreshRate int

// PhaseResult Timing data for a single startup phase
type PhaseResult struct {
	// DurationMs Duration of this phase in milliseconds
	DurationMs *float32 `json:"duration_ms,omitempty"`

	// Name Name of the startup phase
	Name *string `json:"name,omitempty"`

	// Percentage Percentage of total startup time
	Percentage *float32 `json:"percentage,omitempty"`
}

// PhaseSummary Summary statistics for startup phases
type PhaseSummary struct {
	// FastestMs Duration of fastest phase in milliseconds
	FastestMs *float32 `json:"fastest_ms,omitempty"`

	// FastestPhase Name of the fastest phase
	FastestPhase *string `json:"fastest_phase,omitempty"`

	// SlowestMs Duration of slowest phase in milliseconds
	SlowestMs *float32 `json:"slowest_ms,omitempty"`

	// SlowestPhase Name of the slowest phase
	SlowestPhase *string `json:"slowest_phase,omitempty"`
}

// PressKeyRequest defines model for PressKeyRequest.
type PressKeyRequest struct {
	// Duration Duration to hold the keys down in milliseconds. If omitted or 0, keys are tapped.
	Duration *int `json:"duration,omitempty"`

	// HoldKeys Optional modifier keys to hold during the key press sequence.
	HoldKeys *[]string `json:"hold_keys,omitempty"`

	// Keys List of key symbols to press. Each item should be a key symbol supported by xdotool
	// (see X11 keysym definitions). Examples include "Return", "Shift", "Ctrl", "Alt", "F5".
	// Items in this list could also be combinations, e.g. "Ctrl+t" or "Ctrl+Shift+Tab".
	Keys []string `json:"keys"`
}

// ProcessExecRequest Request to execute a command synchronously.
type ProcessExecRequest struct {
	// Args Command arguments.
	Args *[]string `json:"args,omitempty"`

	// AsRoot Run the process with root privileges.
	AsRoot *bool `json:"as_root,omitempty"`

	// AsUser Run the process as this user.
	AsUser *string `json:"as_user"`

	// Command Executable or shell command to run.
	Command string `json:"command"`

	// Cwd Working directory (absolute path) to run the command in.
	Cwd *string `json:"cwd"`

	// Env Environment variables to set for the process.
	Env *map[string]string `json:"env,omitempty"`

	// TimeoutSec Maximum execution time in seconds.
	TimeoutSec *int `json:"timeout_sec"`
}

// ProcessExecResult Result of a synchronous command execution.
type ProcessExecResult struct {
	// DurationMs Execution duration in milliseconds.
	DurationMs *int `json:"duration_ms,omitempty"`

	// ExitCode Process exit code.
	ExitCode *int `json:"exit_code,omitempty"`

	// StderrB64 Base64-encoded stderr buffer.
	StderrB64 *string `json:"stderr_b64,omitempty"`

	// StdoutB64 Base64-encoded stdout buffer.
	StdoutB64 *string `json:"stdout_b64,omitempty"`
}

// ProcessKillRequest Signal to send to the process.
type ProcessKillRequest struct {
	// Signal Signal to send.
	Signal ProcessKillRequestSignal `json:"signal"`
}

// ProcessKillRequestSignal Signal to send.
type ProcessKillRequestSignal string

// ProcessSpawnRequest Request to execute a command synchronously.
type ProcessSpawnRequest = ProcessExecRequest

// ProcessSpawnResult Information about a spawned process.
type ProcessSpawnResult struct {
	// Pid OS process ID.
	Pid *int `json:"pid,omitempty"`

	// ProcessId Server-assigned identifier for the process.
	ProcessId *openapi_types.UUID `json:"process_id,omitempty"`

	// StartedAt Timestamp when the process started.
	StartedAt *time.Time `json:"started_at,omitempty"`
}

// ProcessStatus Current status of a process.
type ProcessStatus struct {
	// CpuPct Estimated CPU usage percentage.
	CpuPct *float32 `json:"cpu_pct,omitempty"`

	// ExitCode Exit code if the process has exited.
	ExitCode *int `json:"exit_code"`

	// MemBytes Estimated resident memory usage in bytes.
	MemBytes *int `json:"mem_bytes,omitempty"`

	// State Process state.
	State *ProcessStatusState `json:"state,omitempty"`
}

// ProcessStatusState Process state.
type ProcessStatusState string

// ProcessStdinRequest Data to write to the process standard input.
type ProcessStdinRequest struct {
	// DataB64 Base64-encoded data to write.
	DataB64 string `json:"data_b64"`
}

// ProcessStdinResult Result of writing to stdin.
type ProcessStdinResult struct {
	// WrittenBytes Number of bytes written.
	WrittenBytes *int `json:"written_bytes,omitempty"`
}

// ProcessStreamEvent SSE payload representing process output or lifecycle events.
type ProcessStreamEvent struct {
	// DataB64 Base64-encoded data from the process stream.
	DataB64 *string `json:"data_b64,omitempty"`

	// Event Lifecycle event type.
	Event *ProcessStreamEventEvent `json:"event,omitempty"`

	// ExitCode Exit code when the event is "exit".
	ExitCode *int `json:"exit_code,omitempty"`

	// Stream Source stream of the data chunk.
	Stream *ProcessStreamEventStream `json:"stream,omitempty"`
}

// ProcessStreamEventEvent Lifecycle event type.
type ProcessStreamEventEvent string

// ProcessStreamEventStream Source stream of the data chunk.
type ProcessStreamEventStream string

// RecorderInfo defines model for RecorderInfo.
type RecorderInfo struct {
	// FinishedAt Timestamp when recording finished
	FinishedAt  *time.Time `json:"finished_at"`
	Id          string     `json:"id"`
	IsRecording bool       `json:"isRecording"`

	// StartedAt Timestamp when recording started
	StartedAt *time.Time `json:"started_at"`
}

// RecordingFrameRateImpact Impact of recording on live view frame rate
type RecordingFrameRateImpact struct {
	// BeforeRecordingFps Frame rate before recording started
	BeforeRecordingFps *float32 `json:"before_recording_fps,omitempty"`

	// DuringRecordingFps Frame rate while recording is active
	DuringRecordingFps *float32 `json:"during_recording_fps,omitempty"`

	// ImpactPercent Percentage change in frame rate (negative means degradation)
	ImpactPercent *float32 `json:"impact_percent,omitempty"`
}

// RecordingResults defines model for RecordingResults.
type RecordingResults struct {
	AvgEncodingLagMs     *float32 `json:"avg_encoding_lag_ms,omitempty"`
	ConcurrentRecordings *int     `json:"concurrent_recordings,omitempty"`
	CpuOverheadPercent   *float32 `json:"cpu_overhead_percent,omitempty"`
	DiskWriteMbps        *float32 `json:"disk_write_mbps,omitempty"`

	// FrameRateImpact Impact of recording on live view frame rate
	FrameRateImpact  *RecordingFrameRateImpact `json:"frame_rate_impact,omitempty"`
	FramesCaptured   *int                      `json:"frames_captured,omitempty"`
	FramesDropped    *int                      `json:"frames_dropped,omitempty"`
	MemoryOverheadMb *float32                  `json:"memory_overhead_mb,omitempty"`
}

// ResolutionMetrics Video resolution
type ResolutionMetrics struct {
	// Height Video height in pixels
	Height *int `json:"height,omitempty"`

	// Width Video width in pixels
	Width *int `json:"width,omitempty"`
}

// ScreenshotRegion defines model for ScreenshotRegion.
type ScreenshotRegion struct {
	// Height Height of the region in pixels
	Height int `json:"height"`

	// Width Width of the region in pixels
	Width int `json:"width"`

	// X X coordinate of the region's top-left corner
	X int `json:"x"`

	// Y Y coordinate of the region's top-left corner
	Y int `json:"y"`
}

// ScreenshotRequest defines model for ScreenshotRequest.
type ScreenshotRequest struct {
	Region *ScreenshotRegion `json:"region,omitempty"`
}

// ScrollRequest defines model for ScrollRequest.
type ScrollRequest struct {
	// DeltaX Horizontal scroll amount. Positive scrolls right, negative scrolls left.
	DeltaX *int `json:"delta_x,omitempty"`

	// DeltaY Vertical scroll amount. Positive scrolls down, negative scrolls up.
	DeltaY *int `json:"delta_y,omitempty"`

	// HoldKeys Modifier keys to hold during the scroll
	HoldKeys *[]string `json:"hold_keys,omitempty"`

	// X X coordinate at which to perform the scroll
	X int `json:"x"`

	// Y Y coordinate at which to perform the scroll
	Y int `json:"y"`
}

// SetCursorRequest defines model for SetCursorRequest.
type SetCursorRequest struct {
	// Hidden Whether the cursor should be hidden
	Hidden bool `json:"hidden"`
}

// SetFilePermissionsRequest defines model for SetFilePermissionsRequest.
type SetFilePermissionsRequest struct {
	// Group New group name or GID.
	Group *string `json:"group,omitempty"`

	// Mode File mode bits (octal string, e.g. 644).
	Mode string `json:"mode"`

	// Owner New owner username or UID.
	Owner *string `json:"owner,omitempty"`

	// Path Absolute path whose permissions are to be changed.
	Path string `json:"path"`
}

// StartFsWatchRequest defines model for StartFsWatchRequest.
type StartFsWatchRequest struct {
	// Path Directory to watch.
	Path string `json:"path"`

	// Recursive Whether to watch recursively.
	Recursive *bool `json:"recursive,omitempty"`
}

// StartRecordingRequest defines model for StartRecordingRequest.
type StartRecordingRequest struct {
	// Framerate Recording framerate in fps (overrides server default)
	Framerate *int `json:"framerate,omitempty"`

	// Id Optional identifier for the recording session. Alphanumeric or hyphen.
	Id *string `json:"id,omitempty"`

	// MaxDurationInSeconds Maximum recording duration in seconds (overrides server default)
	MaxDurationInSeconds *int `json:"maxDurationInSeconds,omitempty"`

	// MaxFileSizeInMB Maximum file size in MB (overrides server default)
	MaxFileSizeInMB *int `json:"maxFileSizeInMB,omitempty"`
}

// StartupTimingResults Container startup timing metrics
type StartupTimingResults struct {
	// PhaseSummary Summary statistics for startup phases
	PhaseSummary *PhaseSummary `json:"phase_summary,omitempty"`

	// Phases Individual startup phases with durations
	Phases *[]PhaseResult `json:"phases,omitempty"`

	// TotalStartupTimeMs Total startup time from container start to ready state
	TotalStartupTimeMs *float32 `json:"total_startup_time_ms,omitempty"`
}

// StopRecordingRequest defines model for StopRecordingRequest.
type StopRecordingRequest struct {
	// ForceStop Immediately stop without graceful shutdown. This may result in a corrupted video file.
	ForceStop *bool `json:"forceStop,omitempty"`

	// Id Identifier of the recorder to stop. Alphanumeric or hyphen.
	Id *string `json:"id,omitempty"`
}

// SystemInfo defines model for SystemInfo.
type SystemInfo struct {
	Arch          *string `json:"arch,omitempty"`
	CpuCount      *int    `json:"cpu_count,omitempty"`
	MemoryTotalMb *int    `json:"memory_total_mb,omitempty"`
	Os            *string `json:"os,omitempty"`
}

// TypeTextRequest defines model for TypeTextRequest.
type TypeTextRequest struct {
	// Delay Delay in milliseconds between keystrokes
	Delay *int `json:"delay,omitempty"`

	// Text Text to type on the host computer
	Text string `json:"text"`
}

// WebRTCLiveViewResults Comprehensive WebRTC live view benchmark results from client
type WebRTCLiveViewResults struct {
	BitrateKbps *BitrateMetrics `json:"bitrate_kbps,omitempty"`

	// Codecs Codec information
	Codecs            *CodecMetrics `json:"codecs,omitempty"`
	ConcurrentViewers *int          `json:"concurrent_viewers,omitempty"`

	// ConnectionState WebRTC connection state
	ConnectionState *string           `json:"connection_state,omitempty"`
	CpuUsagePercent *float32          `json:"cpu_usage_percent,omitempty"`
	FrameLatencyMs  *LatencyMetrics   `json:"frame_latency_ms,omitempty"`
	FrameRateFps    *FrameRateMetrics `json:"frame_rate_fps,omitempty"`

	// Frames Frame statistics for WebRTC video
	Frames *FrameMetrics `json:"frames,omitempty"`

	// IceConnectionState ICE connection state
	IceConnectionState *string `json:"ice_connection_state,omitempty"`

	// JitterMs Jitter measurements in milliseconds
	JitterMs *JitterMetrics `json:"jitter_ms,omitempty"`
	MemoryMb *MemoryMetrics `json:"memory_mb,omitempty"`

	// Network Network-level metrics
	Network *NetworkMetrics `json:"network,omitempty"`

	// Packets Packet statistics for WebRTC streams
	Packets *PacketMetrics `json:"packets,omitempty"`

	// Resolution Video resolution
	Resolution *ResolutionMetrics `json:"resolution,omitempty"`
}

// BadRequestError defines model for BadRequestError.
type BadRequestError = Error

// ConflictError defines model for ConflictError.
type ConflictError = Error

// InternalError defines model for InternalError.
type InternalError = Error

// NotFoundError defines model for NotFoundError.
type NotFoundError = Error

// PatchChromiumFlagsJSONBody defines parameters for PatchChromiumFlags.
type PatchChromiumFlagsJSONBody struct {
	// Flags Chromium flags to merge (e.g., ["--kiosk", "--disable-gpu"])
	Flags []string `json:"flags"`
}

// UploadExtensionsAndRestartMultipartBody defines parameters for UploadExtensionsAndRestart.
type UploadExtensionsAndRestartMultipartBody struct {
	// Extensions List of extensions to upload and activate
	Extensions []struct {
		// Name Folder name to place the extension under /home/kernel/extensions/<name>
		Name string `json:"name"`

		// ZipFile Zip archive containing an unpacked Chromium extension (must include manifest.json)
		ZipFile openapi_types.File `json:"zip_file"`
	} `json:"extensions"`
}

// RunBenchmarkParams defines parameters for RunBenchmark.
type RunBenchmarkParams struct {
	// Components Comma-separated list of components to benchmark (cdp,webrtc,recording,all).
	Components *string `form:"components,omitempty" json:"components,omitempty"`
}

// DownloadDirZipParams defines parameters for DownloadDirZip.
type DownloadDirZipParams struct {
	// Path Absolute directory path to archive and download.
	Path string `form:"path" json:"path"`
}

// FileInfoParams defines parameters for FileInfo.
type FileInfoParams struct {
	// Path Absolute path of the file or directory.
	Path string `form:"path" json:"path"`
}

// ListFilesParams defines parameters for ListFiles.
type ListFilesParams struct {
	// Path Absolute directory path.
	Path string `form:"path" json:"path"`
}

// ReadFileParams defines parameters for ReadFile.
type ReadFileParams struct {
	// Path Absolute file path to read.
	Path string `form:"path" json:"path"`
}

// UploadFilesMultipartBody defines parameters for UploadFiles.
type UploadFilesMultipartBody struct {
	Files []struct {
		// DestPath Absolute destination path to write the file.
		DestPath string             `json:"dest_path"`
		File     openapi_types.File `json:"file"`
	} `json:"files"`
}

// UploadZipMultipartBody defines parameters for UploadZip.
type UploadZipMultipartBody struct {
	// DestPath Absolute destination directory to extract the archive to.
	DestPath string             `json:"dest_path"`
	ZipFile  openapi_types.File `json:"zip_file"`
}

// WriteFileParams defines parameters for WriteFile.
type WriteFileParams struct {
	// Path Destination absolute file path.
	Path string `form:"path" json:"path"`

	// Mode Optional file mode (octal string, e.g. 644). Defaults to 644.
	Mode *string `form:"mode,omitempty" json:"mode,omitempty"`
}

// LogsStreamParams defines parameters for LogsStream.
type LogsStreamParams struct {
	Source LogsStreamParamsSource `form:"source" json:"source"`
	Follow *bool                  `form:"follow,omitempty" json:"follow,omitempty"`

	// Path only required if source is path
	Path *string `form:"path,omitempty" json:"path,omitempty"`

	// SupervisorProcess only required if source is supervisor
	SupervisorProcess *string `form:"supervisor_process,omitempty" json:"supervisor_process,omitempty"`
}

// LogsStreamParamsSource defines parameters for LogsStream.
type LogsStreamParamsSource string

// DownloadRecordingParams defines parameters for DownloadRecording.
type DownloadRecordingParams struct {
	// Id Optional recorder identifier. When omitted, the server uses the default recorder.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// PatchChromiumFlagsJSONRequestBody defines body for PatchChromiumFlags for application/json ContentType.
type PatchChromiumFlagsJSONRequestBody PatchChromiumFlagsJSONBody

// UploadExtensionsAndRestartMultipartRequestBody defines body for UploadExtensionsAndRestart for multipart/form-data ContentType.
type UploadExtensionsAndRestartMultipartRequestBody UploadExtensionsAndRestartMultipartBody

// ClickMouseJSONRequestBody defines body for ClickMouse for application/json ContentType.
type ClickMouseJSONRequestBody = ClickMouseRequest

// SetCursorJSONRequestBody defines body for SetCursor for application/json ContentType.
type SetCursorJSONRequestBody = SetCursorRequest

// DragMouseJSONRequestBody defines body for DragMouse for application/json ContentType.
type DragMouseJSONRequestBody = DragMouseRequest

// MoveMouseJSONRequestBody defines body for MoveMouse for application/json ContentType.
type MoveMouseJSONRequestBody = MoveMouseRequest

// PressKeyJSONRequestBody defines body for PressKey for application/json ContentType.
type PressKeyJSONRequestBody = PressKeyRequest

// TakeScreenshotJSONRequestBody defines body for TakeScreenshot for application/json ContentType.
type TakeScreenshotJSONRequestBody = ScreenshotRequest

// ScrollJSONRequestBody defines body for Scroll for application/json ContentType.
type ScrollJSONRequestBody = ScrollRequest

// TypeTextJSONRequestBody defines body for TypeText for application/json ContentType.
type TypeTextJSONRequestBody = TypeTextRequest

// PatchDisplayJSONRequestBody defines body for PatchDisplay for application/json ContentType.
type PatchDisplayJSONRequestBody = PatchDisplayRequest

// CreateDirectoryJSONRequestBody defines body for CreateDirectory for application/json ContentType.
type CreateDirectoryJSONRequestBody = CreateDirectoryRequest

// DeleteDirectoryJSONRequestBody defines body for DeleteDirectory for application/json ContentType.
type DeleteDirectoryJSONRequestBody = DeletePathRequest

// DeleteFileJSONRequestBody defines body for DeleteFile for application/json ContentType.
type DeleteFileJSONRequestBody = DeletePathRequest

// MovePathJSONRequestBody defines body for MovePath for application/json ContentType.
type MovePathJSONRequestBody = MovePathRequest

// SetFilePermissionsJSONRequestBody defines body for SetFilePermissions for application/json ContentType.
type SetFilePermissionsJSONRequestBody = SetFilePermissionsRequest

// UploadFilesMultipartRequestBody defines body for UploadFiles for multipart/form-data ContentType.
type UploadFilesMultipartRequestBody UploadFilesMultipartBody

// UploadZipMultipartRequestBody defines body for UploadZip for multipart/form-data ContentType.
type UploadZipMultipartRequestBody UploadZipMultipartBody

// StartFsWatchJSONRequestBody defines body for StartFsWatch for application/json ContentType.
type StartFsWatchJSONRequestBody = StartFsWatchRequest

// ExecutePlaywrightCodeJSONRequestBody defines body for ExecutePlaywrightCode for application/json ContentType.
type ExecutePlaywrightCodeJSONRequestBody = ExecutePlaywrightRequest

// ProcessExecJSONRequestBody defines body for ProcessExec for application/json ContentType.
type ProcessExecJSONRequestBody = ProcessExecRequest

// ProcessSpawnJSONRequestBody defines body for ProcessSpawn for application/json ContentType.
type ProcessSpawnJSONRequestBody = ProcessSpawnRequest

// ProcessKillJSONRequestBody defines body for ProcessKill for application/json ContentType.
type ProcessKillJSONRequestBody = ProcessKillRequest

// ProcessStdinJSONRequestBody defines body for ProcessStdin for application/json ContentType.
type ProcessStdinJSONRequestBody = ProcessStdinRequest

// DeleteRecordingJSONRequestBody defines body for DeleteRecording for application/json ContentType.
type DeleteRecordingJSONRequestBody = DeleteRecordingRequest

// StartRecordingJSONRequestBody defines body for StartRecording for application/json ContentType.
type StartRecordingJSONRequestBody = StartRecordingRequest

// StopRecordingJSONRequestBody defines body for StopRecording for application/json ContentType.
type StopRecordingJSONRequestBody = StopRecordingRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PatchChromiumFlagsWithBody request with any body
	PatchChromiumFlagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchChromiumFlags(ctx context.Context, body PatchChromiumFlagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadExtensionsAndRestartWithBody request with any body
	UploadExtensionsAndRestartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClickMouseWithBody request with any body
	ClickMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClickMouse(ctx context.Context, body ClickMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCursorWithBody request with any body
	SetCursorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCursor(ctx context.Context, body SetCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DragMouseWithBody request with any body
	DragMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DragMouse(ctx context.Context, body DragMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MoveMouseWithBody request with any body
	MoveMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MoveMouse(ctx context.Context, body MoveMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PressKeyWithBody request with any body
	PressKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PressKey(ctx context.Context, body PressKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TakeScreenshotWithBody request with any body
	TakeScreenshotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TakeScreenshot(ctx context.Context, body TakeScreenshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScrollWithBody request with any body
	ScrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Scroll(ctx context.Context, body ScrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TypeTextWithBody request with any body
	TypeTextWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TypeText(ctx context.Context, body TypeTextJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunBenchmark request
	RunBenchmark(ctx context.Context, params *RunBenchmarkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchDisplayWithBody request with any body
	PatchDisplayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchDisplay(ctx context.Context, body PatchDisplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDirectoryWithBody request with any body
	CreateDirectoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDirectory(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDirectoryWithBody request with any body
	DeleteDirectoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteDirectory(ctx context.Context, body DeleteDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFileWithBody request with any body
	DeleteFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteFile(ctx context.Context, body DeleteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadDirZip request
	DownloadDirZip(ctx context.Context, params *DownloadDirZipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileInfo request
	FileInfo(ctx context.Context, params *FileInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFiles request
	ListFiles(ctx context.Context, params *ListFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MovePathWithBody request with any body
	MovePathWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MovePath(ctx context.Context, body MovePathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadFile request
	ReadFile(ctx context.Context, params *ReadFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetFilePermissionsWithBody request with any body
	SetFilePermissionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetFilePermissions(ctx context.Context, body SetFilePermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadFilesWithBody request with any body
	UploadFilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadZipWithBody request with any body
	UploadZipWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartFsWatchWithBody request with any body
	StartFsWatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartFsWatch(ctx context.Context, body StartFsWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopFsWatch request
	StopFsWatch(ctx context.Context, watchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamFsEvents request
	StreamFsEvents(ctx context.Context, watchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WriteFileWithBody request with any body
	WriteFileWithBody(ctx context.Context, params *WriteFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogsStream request
	LogsStream(ctx context.Context, params *LogsStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecutePlaywrightCodeWithBody request with any body
	ExecutePlaywrightCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecutePlaywrightCode(ctx context.Context, body ExecutePlaywrightCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessExecWithBody request with any body
	ProcessExecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessExec(ctx context.Context, body ProcessExecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessSpawnWithBody request with any body
	ProcessSpawnWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessSpawn(ctx context.Context, body ProcessSpawnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessKillWithBody request with any body
	ProcessKillWithBody(ctx context.Context, processId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessKill(ctx context.Context, processId openapi_types.UUID, body ProcessKillJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessStatus request
	ProcessStatus(ctx context.Context, processId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessStdinWithBody request with any body
	ProcessStdinWithBody(ctx context.Context, processId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessStdin(ctx context.Context, processId openapi_types.UUID, body ProcessStdinJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessStdoutStream request
	ProcessStdoutStream(ctx context.Context, processId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecordingWithBody request with any body
	DeleteRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRecording(ctx context.Context, body DeleteRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadRecording request
	DownloadRecording(ctx context.Context, params *DownloadRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRecorders request
	ListRecorders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartRecordingWithBody request with any body
	StartRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartRecording(ctx context.Context, body StartRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopRecordingWithBody request with any body
	StopRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopRecording(ctx context.Context, body StopRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PatchChromiumFlagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchChromiumFlagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchChromiumFlags(ctx context.Context, body PatchChromiumFlagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchChromiumFlagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadExtensionsAndRestartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadExtensionsAndRestartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClickMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClickMouseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClickMouse(ctx context.Context, body ClickMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClickMouseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCursorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCursorRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCursor(ctx context.Context, body SetCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCursorRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DragMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDragMouseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DragMouse(ctx context.Context, body DragMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDragMouseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveMouseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveMouseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MoveMouse(ctx context.Context, body MoveMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMoveMouseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PressKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPressKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PressKey(ctx context.Context, body PressKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPressKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TakeScreenshotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTakeScreenshotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TakeScreenshot(ctx context.Context, body TakeScreenshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTakeScreenshotRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Scroll(ctx context.Context, body ScrollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TypeTextWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTypeTextRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TypeText(ctx context.Context, body TypeTextJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTypeTextRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunBenchmark(ctx context.Context, params *RunBenchmarkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunBenchmarkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDisplayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDisplayRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDisplay(ctx context.Context, body PatchDisplayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDisplayRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDirectory(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDirectoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDirectory(ctx context.Context, body DeleteDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDirectoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFile(ctx context.Context, body DeleteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadDirZip(ctx context.Context, params *DownloadDirZipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadDirZipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileInfo(ctx context.Context, params *FileInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFiles(ctx context.Context, params *ListFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovePathWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovePathRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MovePath(ctx context.Context, body MovePathJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMovePathRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadFile(ctx context.Context, params *ReadFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadFileRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFilePermissionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFilePermissionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetFilePermissions(ctx context.Context, body SetFilePermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetFilePermissionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadFilesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadFilesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadZipWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadZipRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartFsWatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartFsWatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartFsWatch(ctx context.Context, body StartFsWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartFsWatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopFsWatch(ctx context.Context, watchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopFsWatchRequest(c.Server, watchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamFsEvents(ctx context.Context, watchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamFsEventsRequest(c.Server, watchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WriteFileWithBody(ctx context.Context, params *WriteFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWriteFileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogsStream(ctx context.Context, params *LogsStreamParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogsStreamRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecutePlaywrightCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecutePlaywrightCodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecutePlaywrightCode(ctx context.Context, body ExecutePlaywrightCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecutePlaywrightCodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessExecWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessExecRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessExec(ctx context.Context, body ProcessExecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessExecRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessSpawnWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessSpawnRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessSpawn(ctx context.Context, body ProcessSpawnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessSpawnRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessKillWithBody(ctx context.Context, processId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessKillRequestWithBody(c.Server, processId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessKill(ctx context.Context, processId openapi_types.UUID, body ProcessKillJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessKillRequest(c.Server, processId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessStatus(ctx context.Context, processId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessStatusRequest(c.Server, processId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessStdinWithBody(ctx context.Context, processId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessStdinRequestWithBody(c.Server, processId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessStdin(ctx context.Context, processId openapi_types.UUID, body ProcessStdinJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessStdinRequest(c.Server, processId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessStdoutStream(ctx context.Context, processId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessStdoutStreamRequest(c.Server, processId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecording(ctx context.Context, body DeleteRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadRecording(ctx context.Context, params *DownloadRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadRecordingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRecorders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRecordersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartRecordingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartRecording(ctx context.Context, body StartRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartRecordingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopRecordingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopRecordingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopRecording(ctx context.Context, body StopRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopRecordingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPatchChromiumFlagsRequest calls the generic PatchChromiumFlags builder with application/json body
func NewPatchChromiumFlagsRequest(server string, body PatchChromiumFlagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchChromiumFlagsRequestWithBody(server, "application/json", bodyReader)
}

// NewPatchChromiumFlagsRequestWithBody generates requests for PatchChromiumFlags with any type of body
func NewPatchChromiumFlagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chromium/flags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadExtensionsAndRestartRequestWithBody generates requests for UploadExtensionsAndRestart with any type of body
func NewUploadExtensionsAndRestartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chromium/upload-extensions-and-restart")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClickMouseRequest calls the generic ClickMouse builder with application/json body
func NewClickMouseRequest(server string, body ClickMouseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClickMouseRequestWithBody(server, "application/json", bodyReader)
}

// NewClickMouseRequestWithBody generates requests for ClickMouse with any type of body
func NewClickMouseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/click_mouse")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetCursorRequest calls the generic SetCursor builder with application/json body
func NewSetCursorRequest(server string, body SetCursorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCursorRequestWithBody(server, "application/json", bodyReader)
}

// NewSetCursorRequestWithBody generates requests for SetCursor with any type of body
func NewSetCursorRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/cursor")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDragMouseRequest calls the generic DragMouse builder with application/json body
func NewDragMouseRequest(server string, body DragMouseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDragMouseRequestWithBody(server, "application/json", bodyReader)
}

// NewDragMouseRequestWithBody generates requests for DragMouse with any type of body
func NewDragMouseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/drag_mouse")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMoveMouseRequest calls the generic MoveMouse builder with application/json body
func NewMoveMouseRequest(server string, body MoveMouseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMoveMouseRequestWithBody(server, "application/json", bodyReader)
}

// NewMoveMouseRequestWithBody generates requests for MoveMouse with any type of body
func NewMoveMouseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/move_mouse")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPressKeyRequest calls the generic PressKey builder with application/json body
func NewPressKeyRequest(server string, body PressKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPressKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewPressKeyRequestWithBody generates requests for PressKey with any type of body
func NewPressKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/press_key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTakeScreenshotRequest calls the generic TakeScreenshot builder with application/json body
func NewTakeScreenshotRequest(server string, body TakeScreenshotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTakeScreenshotRequestWithBody(server, "application/json", bodyReader)
}

// NewTakeScreenshotRequestWithBody generates requests for TakeScreenshot with any type of body
func NewTakeScreenshotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/screenshot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScrollRequest calls the generic Scroll builder with application/json body
func NewScrollRequest(server string, body ScrollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScrollRequestWithBody(server, "application/json", bodyReader)
}

// NewScrollRequestWithBody generates requests for Scroll with any type of body
func NewScrollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/scroll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTypeTextRequest calls the generic TypeText builder with application/json body
func NewTypeTextRequest(server string, body TypeTextJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTypeTextRequestWithBody(server, "application/json", bodyReader)
}

// NewTypeTextRequestWithBody generates requests for TypeText with any type of body
func NewTypeTextRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/computer/type")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunBenchmarkRequest generates requests for RunBenchmark
func NewRunBenchmarkRequest(server string, params *RunBenchmarkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dev/benchmark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Components != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "components", runtime.ParamLocationQuery, *params.Components); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchDisplayRequest calls the generic PatchDisplay builder with application/json body
func NewPatchDisplayRequest(server string, body PatchDisplayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchDisplayRequestWithBody(server, "application/json", bodyReader)
}

// NewPatchDisplayRequestWithBody generates requests for PatchDisplay with any type of body
func NewPatchDisplayRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/display")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDirectoryRequest calls the generic CreateDirectory builder with application/json body
func NewCreateDirectoryRequest(server string, body CreateDirectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDirectoryRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDirectoryRequestWithBody generates requests for CreateDirectory with any type of body
func NewCreateDirectoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/create_directory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDirectoryRequest calls the generic DeleteDirectory builder with application/json body
func NewDeleteDirectoryRequest(server string, body DeleteDirectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteDirectoryRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteDirectoryRequestWithBody generates requests for DeleteDirectory with any type of body
func NewDeleteDirectoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/delete_directory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFileRequest calls the generic DeleteFile builder with application/json body
func NewDeleteFileRequest(server string, body DeleteFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteFileRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteFileRequestWithBody generates requests for DeleteFile with any type of body
func NewDeleteFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/delete_file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadDirZipRequest generates requests for DownloadDirZip
func NewDownloadDirZipRequest(server string, params *DownloadDirZipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/download_dir_zip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFileInfoRequest generates requests for FileInfo
func NewFileInfoRequest(server string, params *FileInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/file_info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFilesRequest generates requests for ListFiles
func NewListFilesRequest(server string, params *ListFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/list_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMovePathRequest calls the generic MovePath builder with application/json body
func NewMovePathRequest(server string, body MovePathJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMovePathRequestWithBody(server, "application/json", bodyReader)
}

// NewMovePathRequestWithBody generates requests for MovePath with any type of body
func NewMovePathRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/move")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReadFileRequest generates requests for ReadFile
func NewReadFileRequest(server string, params *ReadFileParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/read_file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetFilePermissionsRequest calls the generic SetFilePermissions builder with application/json body
func NewSetFilePermissionsRequest(server string, body SetFilePermissionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetFilePermissionsRequestWithBody(server, "application/json", bodyReader)
}

// NewSetFilePermissionsRequestWithBody generates requests for SetFilePermissions with any type of body
func NewSetFilePermissionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/set_file_permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadFilesRequestWithBody generates requests for UploadFiles with any type of body
func NewUploadFilesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadZipRequestWithBody generates requests for UploadZip with any type of body
func NewUploadZipRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/upload_zip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartFsWatchRequest calls the generic StartFsWatch builder with application/json body
func NewStartFsWatchRequest(server string, body StartFsWatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartFsWatchRequestWithBody(server, "application/json", bodyReader)
}

// NewStartFsWatchRequestWithBody generates requests for StartFsWatch with any type of body
func NewStartFsWatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/watch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopFsWatchRequest generates requests for StopFsWatch
func NewStopFsWatchRequest(server string, watchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "watch_id", runtime.ParamLocationPath, watchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/watch/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamFsEventsRequest generates requests for StreamFsEvents
func NewStreamFsEventsRequest(server string, watchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "watch_id", runtime.ParamLocationPath, watchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/watch/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWriteFileRequestWithBody generates requests for WriteFile with any type of body
func NewWriteFileRequestWithBody(server string, params *WriteFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fs/write_file")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogsStreamRequest generates requests for LogsStream
func NewLogsStreamRequest(server string, params *LogsStreamParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs/stream")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, params.Source); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Follow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "follow", runtime.ParamLocationQuery, *params.Follow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Path != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SupervisorProcess != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "supervisor_process", runtime.ParamLocationQuery, *params.SupervisorProcess); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecutePlaywrightCodeRequest calls the generic ExecutePlaywrightCode builder with application/json body
func NewExecutePlaywrightCodeRequest(server string, body ExecutePlaywrightCodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecutePlaywrightCodeRequestWithBody(server, "application/json", bodyReader)
}

// NewExecutePlaywrightCodeRequestWithBody generates requests for ExecutePlaywrightCode with any type of body
func NewExecutePlaywrightCodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playwright/execute")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessExecRequest calls the generic ProcessExec builder with application/json body
func NewProcessExecRequest(server string, body ProcessExecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProcessExecRequestWithBody(server, "application/json", bodyReader)
}

// NewProcessExecRequestWithBody generates requests for ProcessExec with any type of body
func NewProcessExecRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process/exec")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessSpawnRequest calls the generic ProcessSpawn builder with application/json body
func NewProcessSpawnRequest(server string, body ProcessSpawnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProcessSpawnRequestWithBody(server, "application/json", bodyReader)
}

// NewProcessSpawnRequestWithBody generates requests for ProcessSpawn with any type of body
func NewProcessSpawnRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process/spawn")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessKillRequest calls the generic ProcessKill builder with application/json body
func NewProcessKillRequest(server string, processId openapi_types.UUID, body ProcessKillJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProcessKillRequestWithBody(server, processId, "application/json", bodyReader)
}

// NewProcessKillRequestWithBody generates requests for ProcessKill with any type of body
func NewProcessKillRequestWithBody(server string, processId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "process_id", runtime.ParamLocationPath, processId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process/%s/kill", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessStatusRequest generates requests for ProcessStatus
func NewProcessStatusRequest(server string, processId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "process_id", runtime.ParamLocationPath, processId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessStdinRequest calls the generic ProcessStdin builder with application/json body
func NewProcessStdinRequest(server string, processId openapi_types.UUID, body ProcessStdinJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProcessStdinRequestWithBody(server, processId, "application/json", bodyReader)
}

// NewProcessStdinRequestWithBody generates requests for ProcessStdin with any type of body
func NewProcessStdinRequestWithBody(server string, processId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "process_id", runtime.ParamLocationPath, processId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process/%s/stdin", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessStdoutStreamRequest generates requests for ProcessStdoutStream
func NewProcessStdoutStreamRequest(server string, processId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "process_id", runtime.ParamLocationPath, processId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/process/%s/stdout/stream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRecordingRequest calls the generic DeleteRecording builder with application/json body
func NewDeleteRecordingRequest(server string, body DeleteRecordingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRecordingRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteRecordingRequestWithBody generates requests for DeleteRecording with any type of body
func NewDeleteRecordingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDownloadRecordingRequest generates requests for DownloadRecording
func NewDownloadRecordingRequest(server string, params *DownloadRecordingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRecordersRequest generates requests for ListRecorders
func NewListRecordersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartRecordingRequest calls the generic StartRecording builder with application/json body
func NewStartRecordingRequest(server string, body StartRecordingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartRecordingRequestWithBody(server, "application/json", bodyReader)
}

// NewStartRecordingRequestWithBody generates requests for StartRecording with any type of body
func NewStartRecordingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopRecordingRequest calls the generic StopRecording builder with application/json body
func NewStopRecordingRequest(server string, body StopRecordingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopRecordingRequestWithBody(server, "application/json", bodyReader)
}

// NewStopRecordingRequestWithBody generates requests for StopRecording with any type of body
func NewStopRecordingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PatchChromiumFlagsWithBodyWithResponse request with any body
	PatchChromiumFlagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchChromiumFlagsResponse, error)

	PatchChromiumFlagsWithResponse(ctx context.Context, body PatchChromiumFlagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchChromiumFlagsResponse, error)

	// UploadExtensionsAndRestartWithBodyWithResponse request with any body
	UploadExtensionsAndRestartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadExtensionsAndRestartResponse, error)

	// ClickMouseWithBodyWithResponse request with any body
	ClickMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClickMouseResponse, error)

	ClickMouseWithResponse(ctx context.Context, body ClickMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*ClickMouseResponse, error)

	// SetCursorWithBodyWithResponse request with any body
	SetCursorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCursorResponse, error)

	SetCursorWithResponse(ctx context.Context, body SetCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCursorResponse, error)

	// DragMouseWithBodyWithResponse request with any body
	DragMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DragMouseResponse, error)

	DragMouseWithResponse(ctx context.Context, body DragMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*DragMouseResponse, error)

	// MoveMouseWithBodyWithResponse request with any body
	MoveMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveMouseResponse, error)

	MoveMouseWithResponse(ctx context.Context, body MoveMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveMouseResponse, error)

	// PressKeyWithBodyWithResponse request with any body
	PressKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PressKeyResponse, error)

	PressKeyWithResponse(ctx context.Context, body PressKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PressKeyResponse, error)

	// TakeScreenshotWithBodyWithResponse request with any body
	TakeScreenshotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TakeScreenshotResponse, error)

	TakeScreenshotWithResponse(ctx context.Context, body TakeScreenshotJSONRequestBody, reqEditors ...RequestEditorFn) (*TakeScreenshotResponse, error)

	// ScrollWithBodyWithResponse request with any body
	ScrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrollResponse, error)

	ScrollWithResponse(ctx context.Context, body ScrollJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrollResponse, error)

	// TypeTextWithBodyWithResponse request with any body
	TypeTextWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TypeTextResponse, error)

	TypeTextWithResponse(ctx context.Context, body TypeTextJSONRequestBody, reqEditors ...RequestEditorFn) (*TypeTextResponse, error)

	// RunBenchmarkWithResponse request
	RunBenchmarkWithResponse(ctx context.Context, params *RunBenchmarkParams, reqEditors ...RequestEditorFn) (*RunBenchmarkResponse, error)

	// PatchDisplayWithBodyWithResponse request with any body
	PatchDisplayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDisplayResponse, error)

	PatchDisplayWithResponse(ctx context.Context, body PatchDisplayJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDisplayResponse, error)

	// CreateDirectoryWithBodyWithResponse request with any body
	CreateDirectoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectoryResponse, error)

	CreateDirectoryWithResponse(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectoryResponse, error)

	// DeleteDirectoryWithBodyWithResponse request with any body
	DeleteDirectoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteDirectoryResponse, error)

	DeleteDirectoryWithResponse(ctx context.Context, body DeleteDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteDirectoryResponse, error)

	// DeleteFileWithBodyWithResponse request with any body
	DeleteFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error)

	DeleteFileWithResponse(ctx context.Context, body DeleteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error)

	// DownloadDirZipWithResponse request
	DownloadDirZipWithResponse(ctx context.Context, params *DownloadDirZipParams, reqEditors ...RequestEditorFn) (*DownloadDirZipResponse, error)

	// FileInfoWithResponse request
	FileInfoWithResponse(ctx context.Context, params *FileInfoParams, reqEditors ...RequestEditorFn) (*FileInfoResponse, error)

	// ListFilesWithResponse request
	ListFilesWithResponse(ctx context.Context, params *ListFilesParams, reqEditors ...RequestEditorFn) (*ListFilesResponse, error)

	// MovePathWithBodyWithResponse request with any body
	MovePathWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MovePathResponse, error)

	MovePathWithResponse(ctx context.Context, body MovePathJSONRequestBody, reqEditors ...RequestEditorFn) (*MovePathResponse, error)

	// ReadFileWithResponse request
	ReadFileWithResponse(ctx context.Context, params *ReadFileParams, reqEditors ...RequestEditorFn) (*ReadFileResponse, error)

	// SetFilePermissionsWithBodyWithResponse request with any body
	SetFilePermissionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFilePermissionsResponse, error)

	SetFilePermissionsWithResponse(ctx context.Context, body SetFilePermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetFilePermissionsResponse, error)

	// UploadFilesWithBodyWithResponse request with any body
	UploadFilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFilesResponse, error)

	// UploadZipWithBodyWithResponse request with any body
	UploadZipWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadZipResponse, error)

	// StartFsWatchWithBodyWithResponse request with any body
	StartFsWatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartFsWatchResponse, error)

	StartFsWatchWithResponse(ctx context.Context, body StartFsWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*StartFsWatchResponse, error)

	// StopFsWatchWithResponse request
	StopFsWatchWithResponse(ctx context.Context, watchId string, reqEditors ...RequestEditorFn) (*StopFsWatchResponse, error)

	// StreamFsEventsWithResponse request
	StreamFsEventsWithResponse(ctx context.Context, watchId string, reqEditors ...RequestEditorFn) (*StreamFsEventsResponse, error)

	// WriteFileWithBodyWithResponse request with any body
	WriteFileWithBodyWithResponse(ctx context.Context, params *WriteFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WriteFileResponse, error)

	// LogsStreamWithResponse request
	LogsStreamWithResponse(ctx context.Context, params *LogsStreamParams, reqEditors ...RequestEditorFn) (*LogsStreamResponse, error)

	// ExecutePlaywrightCodeWithBodyWithResponse request with any body
	ExecutePlaywrightCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecutePlaywrightCodeResponse, error)

	ExecutePlaywrightCodeWithResponse(ctx context.Context, body ExecutePlaywrightCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecutePlaywrightCodeResponse, error)

	// ProcessExecWithBodyWithResponse request with any body
	ProcessExecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessExecResponse, error)

	ProcessExecWithResponse(ctx context.Context, body ProcessExecJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessExecResponse, error)

	// ProcessSpawnWithBodyWithResponse request with any body
	ProcessSpawnWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessSpawnResponse, error)

	ProcessSpawnWithResponse(ctx context.Context, body ProcessSpawnJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessSpawnResponse, error)

	// ProcessKillWithBodyWithResponse request with any body
	ProcessKillWithBodyWithResponse(ctx context.Context, processId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessKillResponse, error)

	ProcessKillWithResponse(ctx context.Context, processId openapi_types.UUID, body ProcessKillJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessKillResponse, error)

	// ProcessStatusWithResponse request
	ProcessStatusWithResponse(ctx context.Context, processId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ProcessStatusResponse, error)

	// ProcessStdinWithBodyWithResponse request with any body
	ProcessStdinWithBodyWithResponse(ctx context.Context, processId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessStdinResponse, error)

	ProcessStdinWithResponse(ctx context.Context, processId openapi_types.UUID, body ProcessStdinJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessStdinResponse, error)

	// ProcessStdoutStreamWithResponse request
	ProcessStdoutStreamWithResponse(ctx context.Context, processId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ProcessStdoutStreamResponse, error)

	// DeleteRecordingWithBodyWithResponse request with any body
	DeleteRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRecordingResponse, error)

	DeleteRecordingWithResponse(ctx context.Context, body DeleteRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRecordingResponse, error)

	// DownloadRecordingWithResponse request
	DownloadRecordingWithResponse(ctx context.Context, params *DownloadRecordingParams, reqEditors ...RequestEditorFn) (*DownloadRecordingResponse, error)

	// ListRecordersWithResponse request
	ListRecordersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRecordersResponse, error)

	// StartRecordingWithBodyWithResponse request with any body
	StartRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartRecordingResponse, error)

	StartRecordingWithResponse(ctx context.Context, body StartRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*StartRecordingResponse, error)

	// StopRecordingWithBodyWithResponse request with any body
	StopRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopRecordingResponse, error)

	StopRecordingWithResponse(ctx context.Context, body StopRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*StopRecordingResponse, error)
}

type PatchChromiumFlagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r PatchChromiumFlagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchChromiumFlagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadExtensionsAndRestartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UploadExtensionsAndRestartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadExtensionsAndRestartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClickMouseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ClickMouseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClickMouseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCursorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OkResponse
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r SetCursorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCursorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DragMouseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DragMouseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DragMouseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MoveMouseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r MoveMouseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MoveMouseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PressKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r PressKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PressKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TakeScreenshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TakeScreenshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TakeScreenshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScrollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ScrollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScrollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TypeTextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r TypeTextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TypeTextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunBenchmarkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BenchmarkResults
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r RunBenchmarkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunBenchmarkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchDisplayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DisplayConfig
	JSON400      *BadRequestError
	JSON409      *ConflictError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r PatchDisplayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchDisplayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDirectoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r CreateDirectoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDirectoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDirectoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteDirectoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDirectoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadDirZipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadDirZipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadDirZipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileInfo
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r FileInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFiles
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MovePathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r MovePathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MovePathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ReadFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetFilePermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r SetFilePermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetFilePermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UploadFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadZipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r UploadZipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadZipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartFsWatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// WatchId Unique identifier for the directory watch
		WatchId *string `json:"watch_id,omitempty"`
	}
	JSON400 *BadRequestError
	JSON404 *NotFoundError
	JSON500 *InternalError
}

// Status returns HTTPResponse.Status
func (r StartFsWatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartFsWatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopFsWatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r StopFsWatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopFsWatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamFsEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r StreamFsEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamFsEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WriteFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r WriteFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WriteFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogsStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LogsStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogsStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecutePlaywrightCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExecutePlaywrightResult
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ExecutePlaywrightCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecutePlaywrightCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessExecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessExecResult
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ProcessExecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessExecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessSpawnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessSpawnResult
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ProcessSpawnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessSpawnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessKillResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OkResponse
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ProcessKillResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessKillResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessStatus
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ProcessStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessStdinResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessStdinResult
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ProcessStdinResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessStdinResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessStdoutStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ProcessStdoutStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessStdoutStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DeleteRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON404      *NotFoundError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r DownloadRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecordersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RecorderInfo
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r ListRecordersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecordersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON409      *ConflictError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r StartRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestError
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r StopRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PatchChromiumFlagsWithBodyWithResponse request with arbitrary body returning *PatchChromiumFlagsResponse
func (c *ClientWithResponses) PatchChromiumFlagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchChromiumFlagsResponse, error) {
	rsp, err := c.PatchChromiumFlagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchChromiumFlagsResponse(rsp)
}

func (c *ClientWithResponses) PatchChromiumFlagsWithResponse(ctx context.Context, body PatchChromiumFlagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchChromiumFlagsResponse, error) {
	rsp, err := c.PatchChromiumFlags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchChromiumFlagsResponse(rsp)
}

// UploadExtensionsAndRestartWithBodyWithResponse request with arbitrary body returning *UploadExtensionsAndRestartResponse
func (c *ClientWithResponses) UploadExtensionsAndRestartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadExtensionsAndRestartResponse, error) {
	rsp, err := c.UploadExtensionsAndRestartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadExtensionsAndRestartResponse(rsp)
}

// ClickMouseWithBodyWithResponse request with arbitrary body returning *ClickMouseResponse
func (c *ClientWithResponses) ClickMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClickMouseResponse, error) {
	rsp, err := c.ClickMouseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClickMouseResponse(rsp)
}

func (c *ClientWithResponses) ClickMouseWithResponse(ctx context.Context, body ClickMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*ClickMouseResponse, error) {
	rsp, err := c.ClickMouse(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClickMouseResponse(rsp)
}

// SetCursorWithBodyWithResponse request with arbitrary body returning *SetCursorResponse
func (c *ClientWithResponses) SetCursorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCursorResponse, error) {
	rsp, err := c.SetCursorWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCursorResponse(rsp)
}

func (c *ClientWithResponses) SetCursorWithResponse(ctx context.Context, body SetCursorJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCursorResponse, error) {
	rsp, err := c.SetCursor(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCursorResponse(rsp)
}

// DragMouseWithBodyWithResponse request with arbitrary body returning *DragMouseResponse
func (c *ClientWithResponses) DragMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DragMouseResponse, error) {
	rsp, err := c.DragMouseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDragMouseResponse(rsp)
}

func (c *ClientWithResponses) DragMouseWithResponse(ctx context.Context, body DragMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*DragMouseResponse, error) {
	rsp, err := c.DragMouse(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDragMouseResponse(rsp)
}

// MoveMouseWithBodyWithResponse request with arbitrary body returning *MoveMouseResponse
func (c *ClientWithResponses) MoveMouseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MoveMouseResponse, error) {
	rsp, err := c.MoveMouseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveMouseResponse(rsp)
}

func (c *ClientWithResponses) MoveMouseWithResponse(ctx context.Context, body MoveMouseJSONRequestBody, reqEditors ...RequestEditorFn) (*MoveMouseResponse, error) {
	rsp, err := c.MoveMouse(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMoveMouseResponse(rsp)
}

// PressKeyWithBodyWithResponse request with arbitrary body returning *PressKeyResponse
func (c *ClientWithResponses) PressKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PressKeyResponse, error) {
	rsp, err := c.PressKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePressKeyResponse(rsp)
}

func (c *ClientWithResponses) PressKeyWithResponse(ctx context.Context, body PressKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*PressKeyResponse, error) {
	rsp, err := c.PressKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePressKeyResponse(rsp)
}

// TakeScreenshotWithBodyWithResponse request with arbitrary body returning *TakeScreenshotResponse
func (c *ClientWithResponses) TakeScreenshotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TakeScreenshotResponse, error) {
	rsp, err := c.TakeScreenshotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTakeScreenshotResponse(rsp)
}

func (c *ClientWithResponses) TakeScreenshotWithResponse(ctx context.Context, body TakeScreenshotJSONRequestBody, reqEditors ...RequestEditorFn) (*TakeScreenshotResponse, error) {
	rsp, err := c.TakeScreenshot(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTakeScreenshotResponse(rsp)
}

// ScrollWithBodyWithResponse request with arbitrary body returning *ScrollResponse
func (c *ClientWithResponses) ScrollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrollResponse, error) {
	rsp, err := c.ScrollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrollResponse(rsp)
}

func (c *ClientWithResponses) ScrollWithResponse(ctx context.Context, body ScrollJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrollResponse, error) {
	rsp, err := c.Scroll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrollResponse(rsp)
}

// TypeTextWithBodyWithResponse request with arbitrary body returning *TypeTextResponse
func (c *ClientWithResponses) TypeTextWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TypeTextResponse, error) {
	rsp, err := c.TypeTextWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTypeTextResponse(rsp)
}

func (c *ClientWithResponses) TypeTextWithResponse(ctx context.Context, body TypeTextJSONRequestBody, reqEditors ...RequestEditorFn) (*TypeTextResponse, error) {
	rsp, err := c.TypeText(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTypeTextResponse(rsp)
}

// RunBenchmarkWithResponse request returning *RunBenchmarkResponse
func (c *ClientWithResponses) RunBenchmarkWithResponse(ctx context.Context, params *RunBenchmarkParams, reqEditors ...RequestEditorFn) (*RunBenchmarkResponse, error) {
	rsp, err := c.RunBenchmark(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunBenchmarkResponse(rsp)
}

// PatchDisplayWithBodyWithResponse request with arbitrary body returning *PatchDisplayResponse
func (c *ClientWithResponses) PatchDisplayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDisplayResponse, error) {
	rsp, err := c.PatchDisplayWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDisplayResponse(rsp)
}

func (c *ClientWithResponses) PatchDisplayWithResponse(ctx context.Context, body PatchDisplayJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDisplayResponse, error) {
	rsp, err := c.PatchDisplay(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDisplayResponse(rsp)
}

// CreateDirectoryWithBodyWithResponse request with arbitrary body returning *CreateDirectoryResponse
func (c *ClientWithResponses) CreateDirectoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDirectoryResponse, error) {
	rsp, err := c.CreateDirectoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectoryResponse(rsp)
}

func (c *ClientWithResponses) CreateDirectoryWithResponse(ctx context.Context, body CreateDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDirectoryResponse, error) {
	rsp, err := c.CreateDirectory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDirectoryResponse(rsp)
}

// DeleteDirectoryWithBodyWithResponse request with arbitrary body returning *DeleteDirectoryResponse
func (c *ClientWithResponses) DeleteDirectoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteDirectoryResponse, error) {
	rsp, err := c.DeleteDirectoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectoryResponse(rsp)
}

func (c *ClientWithResponses) DeleteDirectoryWithResponse(ctx context.Context, body DeleteDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteDirectoryResponse, error) {
	rsp, err := c.DeleteDirectory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDirectoryResponse(rsp)
}

// DeleteFileWithBodyWithResponse request with arbitrary body returning *DeleteFileResponse
func (c *ClientWithResponses) DeleteFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error) {
	rsp, err := c.DeleteFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFileResponse(rsp)
}

func (c *ClientWithResponses) DeleteFileWithResponse(ctx context.Context, body DeleteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error) {
	rsp, err := c.DeleteFile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFileResponse(rsp)
}

// DownloadDirZipWithResponse request returning *DownloadDirZipResponse
func (c *ClientWithResponses) DownloadDirZipWithResponse(ctx context.Context, params *DownloadDirZipParams, reqEditors ...RequestEditorFn) (*DownloadDirZipResponse, error) {
	rsp, err := c.DownloadDirZip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadDirZipResponse(rsp)
}

// FileInfoWithResponse request returning *FileInfoResponse
func (c *ClientWithResponses) FileInfoWithResponse(ctx context.Context, params *FileInfoParams, reqEditors ...RequestEditorFn) (*FileInfoResponse, error) {
	rsp, err := c.FileInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileInfoResponse(rsp)
}

// ListFilesWithResponse request returning *ListFilesResponse
func (c *ClientWithResponses) ListFilesWithResponse(ctx context.Context, params *ListFilesParams, reqEditors ...RequestEditorFn) (*ListFilesResponse, error) {
	rsp, err := c.ListFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFilesResponse(rsp)
}

// MovePathWithBodyWithResponse request with arbitrary body returning *MovePathResponse
func (c *ClientWithResponses) MovePathWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MovePathResponse, error) {
	rsp, err := c.MovePathWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovePathResponse(rsp)
}

func (c *ClientWithResponses) MovePathWithResponse(ctx context.Context, body MovePathJSONRequestBody, reqEditors ...RequestEditorFn) (*MovePathResponse, error) {
	rsp, err := c.MovePath(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMovePathResponse(rsp)
}

// ReadFileWithResponse request returning *ReadFileResponse
func (c *ClientWithResponses) ReadFileWithResponse(ctx context.Context, params *ReadFileParams, reqEditors ...RequestEditorFn) (*ReadFileResponse, error) {
	rsp, err := c.ReadFile(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadFileResponse(rsp)
}

// SetFilePermissionsWithBodyWithResponse request with arbitrary body returning *SetFilePermissionsResponse
func (c *ClientWithResponses) SetFilePermissionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetFilePermissionsResponse, error) {
	rsp, err := c.SetFilePermissionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFilePermissionsResponse(rsp)
}

func (c *ClientWithResponses) SetFilePermissionsWithResponse(ctx context.Context, body SetFilePermissionsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetFilePermissionsResponse, error) {
	rsp, err := c.SetFilePermissions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetFilePermissionsResponse(rsp)
}

// UploadFilesWithBodyWithResponse request with arbitrary body returning *UploadFilesResponse
func (c *ClientWithResponses) UploadFilesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadFilesResponse, error) {
	rsp, err := c.UploadFilesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadFilesResponse(rsp)
}

// UploadZipWithBodyWithResponse request with arbitrary body returning *UploadZipResponse
func (c *ClientWithResponses) UploadZipWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadZipResponse, error) {
	rsp, err := c.UploadZipWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadZipResponse(rsp)
}

// StartFsWatchWithBodyWithResponse request with arbitrary body returning *StartFsWatchResponse
func (c *ClientWithResponses) StartFsWatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartFsWatchResponse, error) {
	rsp, err := c.StartFsWatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartFsWatchResponse(rsp)
}

func (c *ClientWithResponses) StartFsWatchWithResponse(ctx context.Context, body StartFsWatchJSONRequestBody, reqEditors ...RequestEditorFn) (*StartFsWatchResponse, error) {
	rsp, err := c.StartFsWatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartFsWatchResponse(rsp)
}

// StopFsWatchWithResponse request returning *StopFsWatchResponse
func (c *ClientWithResponses) StopFsWatchWithResponse(ctx context.Context, watchId string, reqEditors ...RequestEditorFn) (*StopFsWatchResponse, error) {
	rsp, err := c.StopFsWatch(ctx, watchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopFsWatchResponse(rsp)
}

// StreamFsEventsWithResponse request returning *StreamFsEventsResponse
func (c *ClientWithResponses) StreamFsEventsWithResponse(ctx context.Context, watchId string, reqEditors ...RequestEditorFn) (*StreamFsEventsResponse, error) {
	rsp, err := c.StreamFsEvents(ctx, watchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamFsEventsResponse(rsp)
}

// WriteFileWithBodyWithResponse request with arbitrary body returning *WriteFileResponse
func (c *ClientWithResponses) WriteFileWithBodyWithResponse(ctx context.Context, params *WriteFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WriteFileResponse, error) {
	rsp, err := c.WriteFileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWriteFileResponse(rsp)
}

// LogsStreamWithResponse request returning *LogsStreamResponse
func (c *ClientWithResponses) LogsStreamWithResponse(ctx context.Context, params *LogsStreamParams, reqEditors ...RequestEditorFn) (*LogsStreamResponse, error) {
	rsp, err := c.LogsStream(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogsStreamResponse(rsp)
}

// ExecutePlaywrightCodeWithBodyWithResponse request with arbitrary body returning *ExecutePlaywrightCodeResponse
func (c *ClientWithResponses) ExecutePlaywrightCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecutePlaywrightCodeResponse, error) {
	rsp, err := c.ExecutePlaywrightCodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecutePlaywrightCodeResponse(rsp)
}

func (c *ClientWithResponses) ExecutePlaywrightCodeWithResponse(ctx context.Context, body ExecutePlaywrightCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecutePlaywrightCodeResponse, error) {
	rsp, err := c.ExecutePlaywrightCode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecutePlaywrightCodeResponse(rsp)
}

// ProcessExecWithBodyWithResponse request with arbitrary body returning *ProcessExecResponse
func (c *ClientWithResponses) ProcessExecWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessExecResponse, error) {
	rsp, err := c.ProcessExecWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessExecResponse(rsp)
}

func (c *ClientWithResponses) ProcessExecWithResponse(ctx context.Context, body ProcessExecJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessExecResponse, error) {
	rsp, err := c.ProcessExec(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessExecResponse(rsp)
}

// ProcessSpawnWithBodyWithResponse request with arbitrary body returning *ProcessSpawnResponse
func (c *ClientWithResponses) ProcessSpawnWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessSpawnResponse, error) {
	rsp, err := c.ProcessSpawnWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessSpawnResponse(rsp)
}

func (c *ClientWithResponses) ProcessSpawnWithResponse(ctx context.Context, body ProcessSpawnJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessSpawnResponse, error) {
	rsp, err := c.ProcessSpawn(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessSpawnResponse(rsp)
}

// ProcessKillWithBodyWithResponse request with arbitrary body returning *ProcessKillResponse
func (c *ClientWithResponses) ProcessKillWithBodyWithResponse(ctx context.Context, processId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessKillResponse, error) {
	rsp, err := c.ProcessKillWithBody(ctx, processId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessKillResponse(rsp)
}

func (c *ClientWithResponses) ProcessKillWithResponse(ctx context.Context, processId openapi_types.UUID, body ProcessKillJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessKillResponse, error) {
	rsp, err := c.ProcessKill(ctx, processId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessKillResponse(rsp)
}

// ProcessStatusWithResponse request returning *ProcessStatusResponse
func (c *ClientWithResponses) ProcessStatusWithResponse(ctx context.Context, processId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ProcessStatusResponse, error) {
	rsp, err := c.ProcessStatus(ctx, processId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessStatusResponse(rsp)
}

// ProcessStdinWithBodyWithResponse request with arbitrary body returning *ProcessStdinResponse
func (c *ClientWithResponses) ProcessStdinWithBodyWithResponse(ctx context.Context, processId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessStdinResponse, error) {
	rsp, err := c.ProcessStdinWithBody(ctx, processId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessStdinResponse(rsp)
}

func (c *ClientWithResponses) ProcessStdinWithResponse(ctx context.Context, processId openapi_types.UUID, body ProcessStdinJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessStdinResponse, error) {
	rsp, err := c.ProcessStdin(ctx, processId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessStdinResponse(rsp)
}

// ProcessStdoutStreamWithResponse request returning *ProcessStdoutStreamResponse
func (c *ClientWithResponses) ProcessStdoutStreamWithResponse(ctx context.Context, processId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ProcessStdoutStreamResponse, error) {
	rsp, err := c.ProcessStdoutStream(ctx, processId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessStdoutStreamResponse(rsp)
}

// DeleteRecordingWithBodyWithResponse request with arbitrary body returning *DeleteRecordingResponse
func (c *ClientWithResponses) DeleteRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRecordingResponse, error) {
	rsp, err := c.DeleteRecordingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordingResponse(rsp)
}

func (c *ClientWithResponses) DeleteRecordingWithResponse(ctx context.Context, body DeleteRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRecordingResponse, error) {
	rsp, err := c.DeleteRecording(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordingResponse(rsp)
}

// DownloadRecordingWithResponse request returning *DownloadRecordingResponse
func (c *ClientWithResponses) DownloadRecordingWithResponse(ctx context.Context, params *DownloadRecordingParams, reqEditors ...RequestEditorFn) (*DownloadRecordingResponse, error) {
	rsp, err := c.DownloadRecording(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadRecordingResponse(rsp)
}

// ListRecordersWithResponse request returning *ListRecordersResponse
func (c *ClientWithResponses) ListRecordersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRecordersResponse, error) {
	rsp, err := c.ListRecorders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRecordersResponse(rsp)
}

// StartRecordingWithBodyWithResponse request with arbitrary body returning *StartRecordingResponse
func (c *ClientWithResponses) StartRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartRecordingResponse, error) {
	rsp, err := c.StartRecordingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartRecordingResponse(rsp)
}

func (c *ClientWithResponses) StartRecordingWithResponse(ctx context.Context, body StartRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*StartRecordingResponse, error) {
	rsp, err := c.StartRecording(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartRecordingResponse(rsp)
}

// StopRecordingWithBodyWithResponse request with arbitrary body returning *StopRecordingResponse
func (c *ClientWithResponses) StopRecordingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopRecordingResponse, error) {
	rsp, err := c.StopRecordingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopRecordingResponse(rsp)
}

func (c *ClientWithResponses) StopRecordingWithResponse(ctx context.Context, body StopRecordingJSONRequestBody, reqEditors ...RequestEditorFn) (*StopRecordingResponse, error) {
	rsp, err := c.StopRecording(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopRecordingResponse(rsp)
}

// ParsePatchChromiumFlagsResponse parses an HTTP response from a PatchChromiumFlagsWithResponse call
func ParsePatchChromiumFlagsResponse(rsp *http.Response) (*PatchChromiumFlagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchChromiumFlagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadExtensionsAndRestartResponse parses an HTTP response from a UploadExtensionsAndRestartWithResponse call
func ParseUploadExtensionsAndRestartResponse(rsp *http.Response) (*UploadExtensionsAndRestartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadExtensionsAndRestartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClickMouseResponse parses an HTTP response from a ClickMouseWithResponse call
func ParseClickMouseResponse(rsp *http.Response) (*ClickMouseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClickMouseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetCursorResponse parses an HTTP response from a SetCursorWithResponse call
func ParseSetCursorResponse(rsp *http.Response) (*SetCursorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCursorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDragMouseResponse parses an HTTP response from a DragMouseWithResponse call
func ParseDragMouseResponse(rsp *http.Response) (*DragMouseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DragMouseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMoveMouseResponse parses an HTTP response from a MoveMouseWithResponse call
func ParseMoveMouseResponse(rsp *http.Response) (*MoveMouseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MoveMouseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePressKeyResponse parses an HTTP response from a PressKeyWithResponse call
func ParsePressKeyResponse(rsp *http.Response) (*PressKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PressKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTakeScreenshotResponse parses an HTTP response from a TakeScreenshotWithResponse call
func ParseTakeScreenshotResponse(rsp *http.Response) (*TakeScreenshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TakeScreenshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScrollResponse parses an HTTP response from a ScrollWithResponse call
func ParseScrollResponse(rsp *http.Response) (*ScrollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScrollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTypeTextResponse parses an HTTP response from a TypeTextWithResponse call
func ParseTypeTextResponse(rsp *http.Response) (*TypeTextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TypeTextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRunBenchmarkResponse parses an HTTP response from a RunBenchmarkWithResponse call
func ParseRunBenchmarkResponse(rsp *http.Response) (*RunBenchmarkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunBenchmarkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BenchmarkResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchDisplayResponse parses an HTTP response from a PatchDisplayWithResponse call
func ParsePatchDisplayResponse(rsp *http.Response) (*PatchDisplayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchDisplayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DisplayConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateDirectoryResponse parses an HTTP response from a CreateDirectoryWithResponse call
func ParseCreateDirectoryResponse(rsp *http.Response) (*CreateDirectoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDirectoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDirectoryResponse parses an HTTP response from a DeleteDirectoryWithResponse call
func ParseDeleteDirectoryResponse(rsp *http.Response) (*DeleteDirectoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDirectoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFileResponse parses an HTTP response from a DeleteFileWithResponse call
func ParseDeleteFileResponse(rsp *http.Response) (*DeleteFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadDirZipResponse parses an HTTP response from a DownloadDirZipWithResponse call
func ParseDownloadDirZipResponse(rsp *http.Response) (*DownloadDirZipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadDirZipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFileInfoResponse parses an HTTP response from a FileInfoWithResponse call
func ParseFileInfoResponse(rsp *http.Response) (*FileInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFilesResponse parses an HTTP response from a ListFilesWithResponse call
func ParseListFilesResponse(rsp *http.Response) (*ListFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMovePathResponse parses an HTTP response from a MovePathWithResponse call
func ParseMovePathResponse(rsp *http.Response) (*MovePathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MovePathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReadFileResponse parses an HTTP response from a ReadFileWithResponse call
func ParseReadFileResponse(rsp *http.Response) (*ReadFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetFilePermissionsResponse parses an HTTP response from a SetFilePermissionsWithResponse call
func ParseSetFilePermissionsResponse(rsp *http.Response) (*SetFilePermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetFilePermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadFilesResponse parses an HTTP response from a UploadFilesWithResponse call
func ParseUploadFilesResponse(rsp *http.Response) (*UploadFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadZipResponse parses an HTTP response from a UploadZipWithResponse call
func ParseUploadZipResponse(rsp *http.Response) (*UploadZipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadZipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartFsWatchResponse parses an HTTP response from a StartFsWatchWithResponse call
func ParseStartFsWatchResponse(rsp *http.Response) (*StartFsWatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartFsWatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// WatchId Unique identifier for the directory watch
			WatchId *string `json:"watch_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopFsWatchResponse parses an HTTP response from a StopFsWatchWithResponse call
func ParseStopFsWatchResponse(rsp *http.Response) (*StopFsWatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopFsWatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStreamFsEventsResponse parses an HTTP response from a StreamFsEventsWithResponse call
func ParseStreamFsEventsResponse(rsp *http.Response) (*StreamFsEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamFsEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWriteFileResponse parses an HTTP response from a WriteFileWithResponse call
func ParseWriteFileResponse(rsp *http.Response) (*WriteFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WriteFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogsStreamResponse parses an HTTP response from a LogsStreamWithResponse call
func ParseLogsStreamResponse(rsp *http.Response) (*LogsStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogsStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExecutePlaywrightCodeResponse parses an HTTP response from a ExecutePlaywrightCodeWithResponse call
func ParseExecutePlaywrightCodeResponse(rsp *http.Response) (*ExecutePlaywrightCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecutePlaywrightCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExecutePlaywrightResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProcessExecResponse parses an HTTP response from a ProcessExecWithResponse call
func ParseProcessExecResponse(rsp *http.Response) (*ProcessExecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessExecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessExecResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProcessSpawnResponse parses an HTTP response from a ProcessSpawnWithResponse call
func ParseProcessSpawnResponse(rsp *http.Response) (*ProcessSpawnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessSpawnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessSpawnResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProcessKillResponse parses an HTTP response from a ProcessKillWithResponse call
func ParseProcessKillResponse(rsp *http.Response) (*ProcessKillResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessKillResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProcessStatusResponse parses an HTTP response from a ProcessStatusWithResponse call
func ParseProcessStatusResponse(rsp *http.Response) (*ProcessStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProcessStdinResponse parses an HTTP response from a ProcessStdinWithResponse call
func ParseProcessStdinResponse(rsp *http.Response) (*ProcessStdinResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessStdinResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessStdinResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProcessStdoutStreamResponse parses an HTTP response from a ProcessStdoutStreamWithResponse call
func ParseProcessStdoutStreamResponse(rsp *http.Response) (*ProcessStdoutStreamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessStdoutStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRecordingResponse parses an HTTP response from a DeleteRecordingWithResponse call
func ParseDeleteRecordingResponse(rsp *http.Response) (*DeleteRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDownloadRecordingResponse parses an HTTP response from a DownloadRecordingWithResponse call
func ParseDownloadRecordingResponse(rsp *http.Response) (*DownloadRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRecordersResponse parses an HTTP response from a ListRecordersWithResponse call
func ParseListRecordersResponse(rsp *http.Response) (*ListRecordersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecordersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RecorderInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartRecordingResponse parses an HTTP response from a StartRecordingWithResponse call
func ParseStartRecordingResponse(rsp *http.Response) (*StartRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopRecordingResponse parses an HTTP response from a StopRecordingWithResponse call
func ParseStopRecordingResponse(rsp *http.Response) (*StopRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Update Chromium launch flags and restart
	// (PATCH /chromium/flags)
	PatchChromiumFlags(w http.ResponseWriter, r *http.Request)
	// Upload one or more unpacked extensions (as zips) and restart Chromium
	// (POST /chromium/upload-extensions-and-restart)
	UploadExtensionsAndRestart(w http.ResponseWriter, r *http.Request)
	// Simulate a mouse click action on the host computer
	// (POST /computer/click_mouse)
	ClickMouse(w http.ResponseWriter, r *http.Request)
	// Hide or show the cursor
	// (POST /computer/cursor)
	SetCursor(w http.ResponseWriter, r *http.Request)
	// Drag the mouse along a path
	// (POST /computer/drag_mouse)
	DragMouse(w http.ResponseWriter, r *http.Request)
	// Move the mouse cursor to the specified coordinates on the host computer
	// (POST /computer/move_mouse)
	MoveMouse(w http.ResponseWriter, r *http.Request)
	// Press one or more keys on the host computer
	// (POST /computer/press_key)
	PressKey(w http.ResponseWriter, r *http.Request)
	// Capture a screenshot of the host computer
	// (POST /computer/screenshot)
	TakeScreenshot(w http.ResponseWriter, r *http.Request)
	// Scroll the mouse wheel at a position on the host computer
	// (POST /computer/scroll)
	Scroll(w http.ResponseWriter, r *http.Request)
	// Type text on the host computer
	// (POST /computer/type)
	TypeText(w http.ResponseWriter, r *http.Request)
	// Run performance benchmarks
	// (GET /dev/benchmark)
	RunBenchmark(w http.ResponseWriter, r *http.Request, params RunBenchmarkParams)
	// Update display configuration
	// (PATCH /display)
	PatchDisplay(w http.ResponseWriter, r *http.Request)
	// Create a new directory
	// (PUT /fs/create_directory)
	CreateDirectory(w http.ResponseWriter, r *http.Request)
	// Delete a directory
	// (PUT /fs/delete_directory)
	DeleteDirectory(w http.ResponseWriter, r *http.Request)
	// Delete a file
	// (PUT /fs/delete_file)
	DeleteFile(w http.ResponseWriter, r *http.Request)
	// Download a directory as a ZIP archive
	// (GET /fs/download_dir_zip)
	DownloadDirZip(w http.ResponseWriter, r *http.Request, params DownloadDirZipParams)
	// Get information about a file or directory
	// (GET /fs/file_info)
	FileInfo(w http.ResponseWriter, r *http.Request, params FileInfoParams)
	// List files in a directory
	// (GET /fs/list_files)
	ListFiles(w http.ResponseWriter, r *http.Request, params ListFilesParams)
	// Move or rename a file or directory
	// (PUT /fs/move)
	MovePath(w http.ResponseWriter, r *http.Request)
	// Read file contents
	// (GET /fs/read_file)
	ReadFile(w http.ResponseWriter, r *http.Request, params ReadFileParams)
	// Set file or directory permissions/ownership
	// (PUT /fs/set_file_permissions)
	SetFilePermissions(w http.ResponseWriter, r *http.Request)
	// Upload one or more files
	// (POST /fs/upload)
	UploadFiles(w http.ResponseWriter, r *http.Request)
	// Upload a zip archive and extract it
	// (POST /fs/upload_zip)
	UploadZip(w http.ResponseWriter, r *http.Request)
	// Watch a directory for changes
	// (POST /fs/watch)
	StartFsWatch(w http.ResponseWriter, r *http.Request)
	// Stop watching a directory
	// (DELETE /fs/watch/{watch_id})
	StopFsWatch(w http.ResponseWriter, r *http.Request, watchId string)
	// Stream filesystem events for a watch
	// (GET /fs/watch/{watch_id}/events)
	StreamFsEvents(w http.ResponseWriter, r *http.Request, watchId string)
	// Write or create a file
	// (PUT /fs/write_file)
	WriteFile(w http.ResponseWriter, r *http.Request, params WriteFileParams)
	// Stream logs over SSE
	// (GET /logs/stream)
	LogsStream(w http.ResponseWriter, r *http.Request, params LogsStreamParams)
	// Execute Playwright/TypeScript code against the browser
	// (POST /playwright/execute)
	ExecutePlaywrightCode(w http.ResponseWriter, r *http.Request)
	// Execute a command synchronously
	// (POST /process/exec)
	ProcessExec(w http.ResponseWriter, r *http.Request)
	// Execute a command asynchronously
	// (POST /process/spawn)
	ProcessSpawn(w http.ResponseWriter, r *http.Request)
	// Send signal to process
	// (POST /process/{process_id}/kill)
	ProcessKill(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID)
	// Get process status
	// (GET /process/{process_id}/status)
	ProcessStatus(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID)
	// Write to process stdin
	// (POST /process/{process_id}/stdin)
	ProcessStdin(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID)
	// Stream process stdout over SSE
	// (GET /process/{process_id}/stdout/stream)
	ProcessStdoutStream(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID)
	// Delete a previously recorded video file
	// (POST /recording/delete)
	DeleteRecording(w http.ResponseWriter, r *http.Request)
	// Download the most recently recorded video file
	// (GET /recording/download)
	DownloadRecording(w http.ResponseWriter, r *http.Request, params DownloadRecordingParams)
	// List all recorders
	// (GET /recording/list)
	ListRecorders(w http.ResponseWriter, r *http.Request)
	// Start a screen recording. Only one recording per ID can be registered at a time.
	// (POST /recording/start)
	StartRecording(w http.ResponseWriter, r *http.Request)
	// Stop the recording
	// (POST /recording/stop)
	StopRecording(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Update Chromium launch flags and restart
// (PATCH /chromium/flags)
func (_ Unimplemented) PatchChromiumFlags(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload one or more unpacked extensions (as zips) and restart Chromium
// (POST /chromium/upload-extensions-and-restart)
func (_ Unimplemented) UploadExtensionsAndRestart(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Simulate a mouse click action on the host computer
// (POST /computer/click_mouse)
func (_ Unimplemented) ClickMouse(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Hide or show the cursor
// (POST /computer/cursor)
func (_ Unimplemented) SetCursor(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Drag the mouse along a path
// (POST /computer/drag_mouse)
func (_ Unimplemented) DragMouse(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Move the mouse cursor to the specified coordinates on the host computer
// (POST /computer/move_mouse)
func (_ Unimplemented) MoveMouse(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Press one or more keys on the host computer
// (POST /computer/press_key)
func (_ Unimplemented) PressKey(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Capture a screenshot of the host computer
// (POST /computer/screenshot)
func (_ Unimplemented) TakeScreenshot(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Scroll the mouse wheel at a position on the host computer
// (POST /computer/scroll)
func (_ Unimplemented) Scroll(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Type text on the host computer
// (POST /computer/type)
func (_ Unimplemented) TypeText(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Run performance benchmarks
// (GET /dev/benchmark)
func (_ Unimplemented) RunBenchmark(w http.ResponseWriter, r *http.Request, params RunBenchmarkParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update display configuration
// (PATCH /display)
func (_ Unimplemented) PatchDisplay(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new directory
// (PUT /fs/create_directory)
func (_ Unimplemented) CreateDirectory(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a directory
// (PUT /fs/delete_directory)
func (_ Unimplemented) DeleteDirectory(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a file
// (PUT /fs/delete_file)
func (_ Unimplemented) DeleteFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Download a directory as a ZIP archive
// (GET /fs/download_dir_zip)
func (_ Unimplemented) DownloadDirZip(w http.ResponseWriter, r *http.Request, params DownloadDirZipParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get information about a file or directory
// (GET /fs/file_info)
func (_ Unimplemented) FileInfo(w http.ResponseWriter, r *http.Request, params FileInfoParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List files in a directory
// (GET /fs/list_files)
func (_ Unimplemented) ListFiles(w http.ResponseWriter, r *http.Request, params ListFilesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Move or rename a file or directory
// (PUT /fs/move)
func (_ Unimplemented) MovePath(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Read file contents
// (GET /fs/read_file)
func (_ Unimplemented) ReadFile(w http.ResponseWriter, r *http.Request, params ReadFileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Set file or directory permissions/ownership
// (PUT /fs/set_file_permissions)
func (_ Unimplemented) SetFilePermissions(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload one or more files
// (POST /fs/upload)
func (_ Unimplemented) UploadFiles(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upload a zip archive and extract it
// (POST /fs/upload_zip)
func (_ Unimplemented) UploadZip(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Watch a directory for changes
// (POST /fs/watch)
func (_ Unimplemented) StartFsWatch(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stop watching a directory
// (DELETE /fs/watch/{watch_id})
func (_ Unimplemented) StopFsWatch(w http.ResponseWriter, r *http.Request, watchId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stream filesystem events for a watch
// (GET /fs/watch/{watch_id}/events)
func (_ Unimplemented) StreamFsEvents(w http.ResponseWriter, r *http.Request, watchId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Write or create a file
// (PUT /fs/write_file)
func (_ Unimplemented) WriteFile(w http.ResponseWriter, r *http.Request, params WriteFileParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stream logs over SSE
// (GET /logs/stream)
func (_ Unimplemented) LogsStream(w http.ResponseWriter, r *http.Request, params LogsStreamParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Execute Playwright/TypeScript code against the browser
// (POST /playwright/execute)
func (_ Unimplemented) ExecutePlaywrightCode(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Execute a command synchronously
// (POST /process/exec)
func (_ Unimplemented) ProcessExec(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Execute a command asynchronously
// (POST /process/spawn)
func (_ Unimplemented) ProcessSpawn(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Send signal to process
// (POST /process/{process_id}/kill)
func (_ Unimplemented) ProcessKill(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get process status
// (GET /process/{process_id}/status)
func (_ Unimplemented) ProcessStatus(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Write to process stdin
// (POST /process/{process_id}/stdin)
func (_ Unimplemented) ProcessStdin(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stream process stdout over SSE
// (GET /process/{process_id}/stdout/stream)
func (_ Unimplemented) ProcessStdoutStream(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a previously recorded video file
// (POST /recording/delete)
func (_ Unimplemented) DeleteRecording(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Download the most recently recorded video file
// (GET /recording/download)
func (_ Unimplemented) DownloadRecording(w http.ResponseWriter, r *http.Request, params DownloadRecordingParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all recorders
// (GET /recording/list)
func (_ Unimplemented) ListRecorders(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Start a screen recording. Only one recording per ID can be registered at a time.
// (POST /recording/start)
func (_ Unimplemented) StartRecording(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Stop the recording
// (POST /recording/stop)
func (_ Unimplemented) StopRecording(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PatchChromiumFlags operation middleware
func (siw *ServerInterfaceWrapper) PatchChromiumFlags(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchChromiumFlags(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadExtensionsAndRestart operation middleware
func (siw *ServerInterfaceWrapper) UploadExtensionsAndRestart(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadExtensionsAndRestart(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ClickMouse operation middleware
func (siw *ServerInterfaceWrapper) ClickMouse(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ClickMouse(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetCursor operation middleware
func (siw *ServerInterfaceWrapper) SetCursor(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetCursor(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DragMouse operation middleware
func (siw *ServerInterfaceWrapper) DragMouse(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DragMouse(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// MoveMouse operation middleware
func (siw *ServerInterfaceWrapper) MoveMouse(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MoveMouse(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PressKey operation middleware
func (siw *ServerInterfaceWrapper) PressKey(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PressKey(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TakeScreenshot operation middleware
func (siw *ServerInterfaceWrapper) TakeScreenshot(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TakeScreenshot(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Scroll operation middleware
func (siw *ServerInterfaceWrapper) Scroll(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Scroll(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TypeText operation middleware
func (siw *ServerInterfaceWrapper) TypeText(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TypeText(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RunBenchmark operation middleware
func (siw *ServerInterfaceWrapper) RunBenchmark(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params RunBenchmarkParams

	// ------------- Optional query parameter "components" -------------

	err = runtime.BindQueryParameter("form", true, false, "components", r.URL.Query(), &params.Components)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "components", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunBenchmark(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchDisplay operation middleware
func (siw *ServerInterfaceWrapper) PatchDisplay(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchDisplay(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDirectory operation middleware
func (siw *ServerInterfaceWrapper) CreateDirectory(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDirectory(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDirectory operation middleware
func (siw *ServerInterfaceWrapper) DeleteDirectory(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDirectory(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadDirZip operation middleware
func (siw *ServerInterfaceWrapper) DownloadDirZip(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadDirZipParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadDirZip(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// FileInfo operation middleware
func (siw *ServerInterfaceWrapper) FileInfo(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FileInfoParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FileInfo(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFiles operation middleware
func (siw *ServerInterfaceWrapper) ListFiles(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFilesParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFiles(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// MovePath operation middleware
func (siw *ServerInterfaceWrapper) MovePath(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MovePath(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadFile operation middleware
func (siw *ServerInterfaceWrapper) ReadFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ReadFileParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadFile(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetFilePermissions operation middleware
func (siw *ServerInterfaceWrapper) SetFilePermissions(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetFilePermissions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadFiles operation middleware
func (siw *ServerInterfaceWrapper) UploadFiles(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadFiles(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadZip operation middleware
func (siw *ServerInterfaceWrapper) UploadZip(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadZip(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StartFsWatch operation middleware
func (siw *ServerInterfaceWrapper) StartFsWatch(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartFsWatch(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StopFsWatch operation middleware
func (siw *ServerInterfaceWrapper) StopFsWatch(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "watch_id" -------------
	var watchId string

	err = runtime.BindStyledParameterWithOptions("simple", "watch_id", chi.URLParam(r, "watch_id"), &watchId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "watch_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StopFsWatch(w, r, watchId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StreamFsEvents operation middleware
func (siw *ServerInterfaceWrapper) StreamFsEvents(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "watch_id" -------------
	var watchId string

	err = runtime.BindStyledParameterWithOptions("simple", "watch_id", chi.URLParam(r, "watch_id"), &watchId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "watch_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StreamFsEvents(w, r, watchId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WriteFile operation middleware
func (siw *ServerInterfaceWrapper) WriteFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params WriteFileParams

	// ------------- Required query parameter "path" -------------

	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// ------------- Optional query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, false, "mode", r.URL.Query(), &params.Mode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "mode", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WriteFile(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LogsStream operation middleware
func (siw *ServerInterfaceWrapper) LogsStream(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LogsStreamParams

	// ------------- Required query parameter "source" -------------

	if paramValue := r.URL.Query().Get("source"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "source"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "source", r.URL.Query(), &params.Source)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "source", Err: err})
		return
	}

	// ------------- Optional query parameter "follow" -------------

	err = runtime.BindQueryParameter("form", true, false, "follow", r.URL.Query(), &params.Follow)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "follow", Err: err})
		return
	}

	// ------------- Optional query parameter "path" -------------

	err = runtime.BindQueryParameter("form", true, false, "path", r.URL.Query(), &params.Path)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	// ------------- Optional query parameter "supervisor_process" -------------

	err = runtime.BindQueryParameter("form", true, false, "supervisor_process", r.URL.Query(), &params.SupervisorProcess)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "supervisor_process", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LogsStream(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ExecutePlaywrightCode operation middleware
func (siw *ServerInterfaceWrapper) ExecutePlaywrightCode(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecutePlaywrightCode(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ProcessExec operation middleware
func (siw *ServerInterfaceWrapper) ProcessExec(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessExec(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ProcessSpawn operation middleware
func (siw *ServerInterfaceWrapper) ProcessSpawn(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessSpawn(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ProcessKill operation middleware
func (siw *ServerInterfaceWrapper) ProcessKill(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "process_id" -------------
	var processId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "process_id", chi.URLParam(r, "process_id"), &processId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "process_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessKill(w, r, processId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ProcessStatus operation middleware
func (siw *ServerInterfaceWrapper) ProcessStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "process_id" -------------
	var processId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "process_id", chi.URLParam(r, "process_id"), &processId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "process_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessStatus(w, r, processId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ProcessStdin operation middleware
func (siw *ServerInterfaceWrapper) ProcessStdin(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "process_id" -------------
	var processId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "process_id", chi.URLParam(r, "process_id"), &processId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "process_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessStdin(w, r, processId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ProcessStdoutStream operation middleware
func (siw *ServerInterfaceWrapper) ProcessStdoutStream(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "process_id" -------------
	var processId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "process_id", chi.URLParam(r, "process_id"), &processId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "process_id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ProcessStdoutStream(w, r, processId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteRecording operation middleware
func (siw *ServerInterfaceWrapper) DeleteRecording(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRecording(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DownloadRecording operation middleware
func (siw *ServerInterfaceWrapper) DownloadRecording(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DownloadRecordingParams

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadRecording(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListRecorders operation middleware
func (siw *ServerInterfaceWrapper) ListRecorders(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRecorders(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StartRecording operation middleware
func (siw *ServerInterfaceWrapper) StartRecording(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StartRecording(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StopRecording operation middleware
func (siw *ServerInterfaceWrapper) StopRecording(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StopRecording(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/chromium/flags", wrapper.PatchChromiumFlags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/chromium/upload-extensions-and-restart", wrapper.UploadExtensionsAndRestart)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/click_mouse", wrapper.ClickMouse)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/cursor", wrapper.SetCursor)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/drag_mouse", wrapper.DragMouse)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/move_mouse", wrapper.MoveMouse)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/press_key", wrapper.PressKey)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/screenshot", wrapper.TakeScreenshot)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/scroll", wrapper.Scroll)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/computer/type", wrapper.TypeText)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/dev/benchmark", wrapper.RunBenchmark)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/display", wrapper.PatchDisplay)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/fs/create_directory", wrapper.CreateDirectory)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/fs/delete_directory", wrapper.DeleteDirectory)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/fs/delete_file", wrapper.DeleteFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fs/download_dir_zip", wrapper.DownloadDirZip)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fs/file_info", wrapper.FileInfo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fs/list_files", wrapper.ListFiles)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/fs/move", wrapper.MovePath)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fs/read_file", wrapper.ReadFile)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/fs/set_file_permissions", wrapper.SetFilePermissions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/fs/upload", wrapper.UploadFiles)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/fs/upload_zip", wrapper.UploadZip)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/fs/watch", wrapper.StartFsWatch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/fs/watch/{watch_id}", wrapper.StopFsWatch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/fs/watch/{watch_id}/events", wrapper.StreamFsEvents)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/fs/write_file", wrapper.WriteFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/logs/stream", wrapper.LogsStream)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/playwright/execute", wrapper.ExecutePlaywrightCode)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/process/exec", wrapper.ProcessExec)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/process/spawn", wrapper.ProcessSpawn)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/process/{process_id}/kill", wrapper.ProcessKill)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/process/{process_id}/status", wrapper.ProcessStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/process/{process_id}/stdin", wrapper.ProcessStdin)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/process/{process_id}/stdout/stream", wrapper.ProcessStdoutStream)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/recording/delete", wrapper.DeleteRecording)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recording/download", wrapper.DownloadRecording)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/recording/list", wrapper.ListRecorders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/recording/start", wrapper.StartRecording)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/recording/stop", wrapper.StopRecording)
	})

	return r
}

type BadRequestErrorJSONResponse Error

type ConflictErrorJSONResponse Error

type InternalErrorJSONResponse Error

type NotFoundErrorJSONResponse Error

type PatchChromiumFlagsRequestObject struct {
	Body *PatchChromiumFlagsJSONRequestBody
}

type PatchChromiumFlagsResponseObject interface {
	VisitPatchChromiumFlagsResponse(w http.ResponseWriter) error
}

type PatchChromiumFlags200Response struct {
}

func (response PatchChromiumFlags200Response) VisitPatchChromiumFlagsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PatchChromiumFlags400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PatchChromiumFlags400JSONResponse) VisitPatchChromiumFlagsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PatchChromiumFlags500JSONResponse struct{ InternalErrorJSONResponse }

func (response PatchChromiumFlags500JSONResponse) VisitPatchChromiumFlagsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UploadExtensionsAndRestartRequestObject struct {
	Body *multipart.Reader
}

type UploadExtensionsAndRestartResponseObject interface {
	VisitUploadExtensionsAndRestartResponse(w http.ResponseWriter) error
}

type UploadExtensionsAndRestart201Response struct {
}

func (response UploadExtensionsAndRestart201Response) VisitUploadExtensionsAndRestartResponse(w http.ResponseWriter) error {
	w.WriteHeader(201)
	return nil
}

type UploadExtensionsAndRestart400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UploadExtensionsAndRestart400JSONResponse) VisitUploadExtensionsAndRestartResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UploadExtensionsAndRestart500JSONResponse struct{ InternalErrorJSONResponse }

func (response UploadExtensionsAndRestart500JSONResponse) VisitUploadExtensionsAndRestartResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ClickMouseRequestObject struct {
	Body *ClickMouseJSONRequestBody
}

type ClickMouseResponseObject interface {
	VisitClickMouseResponse(w http.ResponseWriter) error
}

type ClickMouse200Response struct {
}

func (response ClickMouse200Response) VisitClickMouseResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type ClickMouse400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ClickMouse400JSONResponse) VisitClickMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ClickMouse500JSONResponse struct{ InternalErrorJSONResponse }

func (response ClickMouse500JSONResponse) VisitClickMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type SetCursorRequestObject struct {
	Body *SetCursorJSONRequestBody
}

type SetCursorResponseObject interface {
	VisitSetCursorResponse(w http.ResponseWriter) error
}

type SetCursor200JSONResponse OkResponse

func (response SetCursor200JSONResponse) VisitSetCursorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SetCursor400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response SetCursor400JSONResponse) VisitSetCursorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type SetCursor500JSONResponse struct{ InternalErrorJSONResponse }

func (response SetCursor500JSONResponse) VisitSetCursorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DragMouseRequestObject struct {
	Body *DragMouseJSONRequestBody
}

type DragMouseResponseObject interface {
	VisitDragMouseResponse(w http.ResponseWriter) error
}

type DragMouse200Response struct {
}

func (response DragMouse200Response) VisitDragMouseResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DragMouse400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DragMouse400JSONResponse) VisitDragMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DragMouse500JSONResponse struct{ InternalErrorJSONResponse }

func (response DragMouse500JSONResponse) VisitDragMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type MoveMouseRequestObject struct {
	Body *MoveMouseJSONRequestBody
}

type MoveMouseResponseObject interface {
	VisitMoveMouseResponse(w http.ResponseWriter) error
}

type MoveMouse200Response struct {
}

func (response MoveMouse200Response) VisitMoveMouseResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type MoveMouse400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response MoveMouse400JSONResponse) VisitMoveMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type MoveMouse500JSONResponse struct{ InternalErrorJSONResponse }

func (response MoveMouse500JSONResponse) VisitMoveMouseResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PressKeyRequestObject struct {
	Body *PressKeyJSONRequestBody
}

type PressKeyResponseObject interface {
	VisitPressKeyResponse(w http.ResponseWriter) error
}

type PressKey200Response struct {
}

func (response PressKey200Response) VisitPressKeyResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type PressKey400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PressKey400JSONResponse) VisitPressKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PressKey500JSONResponse struct{ InternalErrorJSONResponse }

func (response PressKey500JSONResponse) VisitPressKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type TakeScreenshotRequestObject struct {
	Body *TakeScreenshotJSONRequestBody
}

type TakeScreenshotResponseObject interface {
	VisitTakeScreenshotResponse(w http.ResponseWriter) error
}

type TakeScreenshot200ImagepngResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response TakeScreenshot200ImagepngResponse) VisitTakeScreenshotResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "image/png")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type TakeScreenshot400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response TakeScreenshot400JSONResponse) VisitTakeScreenshotResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type TakeScreenshot500JSONResponse struct{ InternalErrorJSONResponse }

func (response TakeScreenshot500JSONResponse) VisitTakeScreenshotResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ScrollRequestObject struct {
	Body *ScrollJSONRequestBody
}

type ScrollResponseObject interface {
	VisitScrollResponse(w http.ResponseWriter) error
}

type Scroll200Response struct {
}

func (response Scroll200Response) VisitScrollResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type Scroll400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response Scroll400JSONResponse) VisitScrollResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type Scroll500JSONResponse struct{ InternalErrorJSONResponse }

func (response Scroll500JSONResponse) VisitScrollResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type TypeTextRequestObject struct {
	Body *TypeTextJSONRequestBody
}

type TypeTextResponseObject interface {
	VisitTypeTextResponse(w http.ResponseWriter) error
}

type TypeText200Response struct {
}

func (response TypeText200Response) VisitTypeTextResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type TypeText400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response TypeText400JSONResponse) VisitTypeTextResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type TypeText500JSONResponse struct{ InternalErrorJSONResponse }

func (response TypeText500JSONResponse) VisitTypeTextResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RunBenchmarkRequestObject struct {
	Params RunBenchmarkParams
}

type RunBenchmarkResponseObject interface {
	VisitRunBenchmarkResponse(w http.ResponseWriter) error
}

type RunBenchmark200JSONResponse BenchmarkResults

func (response RunBenchmark200JSONResponse) VisitRunBenchmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RunBenchmark400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response RunBenchmark400JSONResponse) VisitRunBenchmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RunBenchmark500JSONResponse struct{ InternalErrorJSONResponse }

func (response RunBenchmark500JSONResponse) VisitRunBenchmarkResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PatchDisplayRequestObject struct {
	Body *PatchDisplayJSONRequestBody
}

type PatchDisplayResponseObject interface {
	VisitPatchDisplayResponse(w http.ResponseWriter) error
}

type PatchDisplay200JSONResponse DisplayConfig

func (response PatchDisplay200JSONResponse) VisitPatchDisplayResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PatchDisplay400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response PatchDisplay400JSONResponse) VisitPatchDisplayResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PatchDisplay409JSONResponse struct{ ConflictErrorJSONResponse }

func (response PatchDisplay409JSONResponse) VisitPatchDisplayResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type PatchDisplay500JSONResponse struct{ InternalErrorJSONResponse }

func (response PatchDisplay500JSONResponse) VisitPatchDisplayResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateDirectoryRequestObject struct {
	Body *CreateDirectoryJSONRequestBody
}

type CreateDirectoryResponseObject interface {
	VisitCreateDirectoryResponse(w http.ResponseWriter) error
}

type CreateDirectory201Response struct {
}

func (response CreateDirectory201Response) VisitCreateDirectoryResponse(w http.ResponseWriter) error {
	w.WriteHeader(201)
	return nil
}

type CreateDirectory400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response CreateDirectory400JSONResponse) VisitCreateDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateDirectory500JSONResponse struct{ InternalErrorJSONResponse }

func (response CreateDirectory500JSONResponse) VisitCreateDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteDirectoryRequestObject struct {
	Body *DeleteDirectoryJSONRequestBody
}

type DeleteDirectoryResponseObject interface {
	VisitDeleteDirectoryResponse(w http.ResponseWriter) error
}

type DeleteDirectory200Response struct {
}

func (response DeleteDirectory200Response) VisitDeleteDirectoryResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DeleteDirectory400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteDirectory400JSONResponse) VisitDeleteDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteDirectory404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteDirectory404JSONResponse) VisitDeleteDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteDirectory500JSONResponse struct{ InternalErrorJSONResponse }

func (response DeleteDirectory500JSONResponse) VisitDeleteDirectoryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFileRequestObject struct {
	Body *DeleteFileJSONRequestBody
}

type DeleteFileResponseObject interface {
	VisitDeleteFileResponse(w http.ResponseWriter) error
}

type DeleteFile200Response struct {
}

func (response DeleteFile200Response) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DeleteFile400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteFile400JSONResponse) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFile404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteFile404JSONResponse) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteFile500JSONResponse struct{ InternalErrorJSONResponse }

func (response DeleteFile500JSONResponse) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DownloadDirZipRequestObject struct {
	Params DownloadDirZipParams
}

type DownloadDirZipResponseObject interface {
	VisitDownloadDirZipResponse(w http.ResponseWriter) error
}

type DownloadDirZip200ApplicationzipResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response DownloadDirZip200ApplicationzipResponse) VisitDownloadDirZipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/zip")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DownloadDirZip400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DownloadDirZip400JSONResponse) VisitDownloadDirZipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DownloadDirZip404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DownloadDirZip404JSONResponse) VisitDownloadDirZipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DownloadDirZip500JSONResponse struct{ InternalErrorJSONResponse }

func (response DownloadDirZip500JSONResponse) VisitDownloadDirZipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type FileInfoRequestObject struct {
	Params FileInfoParams
}

type FileInfoResponseObject interface {
	VisitFileInfoResponse(w http.ResponseWriter) error
}

type FileInfo200JSONResponse FileInfo

func (response FileInfo200JSONResponse) VisitFileInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type FileInfo400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response FileInfo400JSONResponse) VisitFileInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type FileInfo404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response FileInfo404JSONResponse) VisitFileInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type FileInfo500JSONResponse struct{ InternalErrorJSONResponse }

func (response FileInfo500JSONResponse) VisitFileInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesRequestObject struct {
	Params ListFilesParams
}

type ListFilesResponseObject interface {
	VisitListFilesResponse(w http.ResponseWriter) error
}

type ListFiles200JSONResponse ListFiles

func (response ListFiles200JSONResponse) VisitListFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListFiles400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ListFiles400JSONResponse) VisitListFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ListFiles404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ListFiles404JSONResponse) VisitListFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListFiles500JSONResponse struct{ InternalErrorJSONResponse }

func (response ListFiles500JSONResponse) VisitListFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type MovePathRequestObject struct {
	Body *MovePathJSONRequestBody
}

type MovePathResponseObject interface {
	VisitMovePathResponse(w http.ResponseWriter) error
}

type MovePath200Response struct {
}

func (response MovePath200Response) VisitMovePathResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type MovePath400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response MovePath400JSONResponse) VisitMovePathResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type MovePath404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response MovePath404JSONResponse) VisitMovePathResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type MovePath500JSONResponse struct{ InternalErrorJSONResponse }

func (response MovePath500JSONResponse) VisitMovePathResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ReadFileRequestObject struct {
	Params ReadFileParams
}

type ReadFileResponseObject interface {
	VisitReadFileResponse(w http.ResponseWriter) error
}

type ReadFile200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response ReadFile200ApplicationoctetStreamResponse) VisitReadFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type ReadFile400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ReadFile400JSONResponse) VisitReadFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ReadFile404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ReadFile404JSONResponse) VisitReadFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ReadFile500JSONResponse struct{ InternalErrorJSONResponse }

func (response ReadFile500JSONResponse) VisitReadFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type SetFilePermissionsRequestObject struct {
	Body *SetFilePermissionsJSONRequestBody
}

type SetFilePermissionsResponseObject interface {
	VisitSetFilePermissionsResponse(w http.ResponseWriter) error
}

type SetFilePermissions200Response struct {
}

func (response SetFilePermissions200Response) VisitSetFilePermissionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type SetFilePermissions400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response SetFilePermissions400JSONResponse) VisitSetFilePermissionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type SetFilePermissions404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response SetFilePermissions404JSONResponse) VisitSetFilePermissionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type SetFilePermissions500JSONResponse struct{ InternalErrorJSONResponse }

func (response SetFilePermissions500JSONResponse) VisitSetFilePermissionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UploadFilesRequestObject struct {
	Body *multipart.Reader
}

type UploadFilesResponseObject interface {
	VisitUploadFilesResponse(w http.ResponseWriter) error
}

type UploadFiles201Response struct {
}

func (response UploadFiles201Response) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.WriteHeader(201)
	return nil
}

type UploadFiles400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UploadFiles400JSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UploadFiles404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response UploadFiles404JSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UploadFiles500JSONResponse struct{ InternalErrorJSONResponse }

func (response UploadFiles500JSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UploadZipRequestObject struct {
	Body *multipart.Reader
}

type UploadZipResponseObject interface {
	VisitUploadZipResponse(w http.ResponseWriter) error
}

type UploadZip201Response struct {
}

func (response UploadZip201Response) VisitUploadZipResponse(w http.ResponseWriter) error {
	w.WriteHeader(201)
	return nil
}

type UploadZip400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response UploadZip400JSONResponse) VisitUploadZipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type UploadZip404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response UploadZip404JSONResponse) VisitUploadZipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UploadZip500JSONResponse struct{ InternalErrorJSONResponse }

func (response UploadZip500JSONResponse) VisitUploadZipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type StartFsWatchRequestObject struct {
	Body *StartFsWatchJSONRequestBody
}

type StartFsWatchResponseObject interface {
	VisitStartFsWatchResponse(w http.ResponseWriter) error
}

type StartFsWatch201JSONResponse struct {
	// WatchId Unique identifier for the directory watch
	WatchId *string `json:"watch_id,omitempty"`
}

func (response StartFsWatch201JSONResponse) VisitStartFsWatchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type StartFsWatch400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response StartFsWatch400JSONResponse) VisitStartFsWatchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type StartFsWatch404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response StartFsWatch404JSONResponse) VisitStartFsWatchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type StartFsWatch500JSONResponse struct{ InternalErrorJSONResponse }

func (response StartFsWatch500JSONResponse) VisitStartFsWatchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type StopFsWatchRequestObject struct {
	WatchId string `json:"watch_id"`
}

type StopFsWatchResponseObject interface {
	VisitStopFsWatchResponse(w http.ResponseWriter) error
}

type StopFsWatch204Response struct {
}

func (response StopFsWatch204Response) VisitStopFsWatchResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type StopFsWatch400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response StopFsWatch400JSONResponse) VisitStopFsWatchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type StopFsWatch404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response StopFsWatch404JSONResponse) VisitStopFsWatchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type StopFsWatch500JSONResponse struct{ InternalErrorJSONResponse }

func (response StopFsWatch500JSONResponse) VisitStopFsWatchResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type StreamFsEventsRequestObject struct {
	WatchId string `json:"watch_id"`
}

type StreamFsEventsResponseObject interface {
	VisitStreamFsEventsResponse(w http.ResponseWriter) error
}

type StreamFsEvents200ResponseHeaders struct {
	XSSEContentType string
}

type StreamFsEvents200TexteventStreamResponse struct {
	Body          io.Reader
	Headers       StreamFsEvents200ResponseHeaders
	ContentLength int64
}

func (response StreamFsEvents200TexteventStreamResponse) VisitStreamFsEventsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/event-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("X-SSE-Content-Type", fmt.Sprint(response.Headers.XSSEContentType))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	flusher, ok := w.(http.Flusher)
	if !ok {
		// If w doesn't support flushing, might as well use io.Copy
		_, err := io.Copy(w, response.Body)
		return err
	}

	// Use a buffer for efficient copying and flushing
	buf := make([]byte, 4096) // text/event-stream are usually very small messages
	for {
		n, err := response.Body.Read(buf)
		if n > 0 {
			if _, werr := w.Write(buf[:n]); werr != nil {
				return werr
			}
			flusher.Flush() // Flush after each write
		}
		if err != nil {
			if err == io.EOF {
				return nil // End of file, no error
			}
			return err
		}
	}
}

type StreamFsEvents400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response StreamFsEvents400JSONResponse) VisitStreamFsEventsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type StreamFsEvents404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response StreamFsEvents404JSONResponse) VisitStreamFsEventsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type StreamFsEvents500JSONResponse struct{ InternalErrorJSONResponse }

func (response StreamFsEvents500JSONResponse) VisitStreamFsEventsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type WriteFileRequestObject struct {
	Params WriteFileParams
	Body   io.Reader
}

type WriteFileResponseObject interface {
	VisitWriteFileResponse(w http.ResponseWriter) error
}

type WriteFile201Response struct {
}

func (response WriteFile201Response) VisitWriteFileResponse(w http.ResponseWriter) error {
	w.WriteHeader(201)
	return nil
}

type WriteFile400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response WriteFile400JSONResponse) VisitWriteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type WriteFile404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response WriteFile404JSONResponse) VisitWriteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type WriteFile500JSONResponse struct{ InternalErrorJSONResponse }

func (response WriteFile500JSONResponse) VisitWriteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type LogsStreamRequestObject struct {
	Params LogsStreamParams
}

type LogsStreamResponseObject interface {
	VisitLogsStreamResponse(w http.ResponseWriter) error
}

type LogsStream200ResponseHeaders struct {
	XSSEContentType string
}

type LogsStream200TexteventStreamResponse struct {
	Body          io.Reader
	Headers       LogsStream200ResponseHeaders
	ContentLength int64
}

func (response LogsStream200TexteventStreamResponse) VisitLogsStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/event-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("X-SSE-Content-Type", fmt.Sprint(response.Headers.XSSEContentType))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	flusher, ok := w.(http.Flusher)
	if !ok {
		// If w doesn't support flushing, might as well use io.Copy
		_, err := io.Copy(w, response.Body)
		return err
	}

	// Use a buffer for efficient copying and flushing
	buf := make([]byte, 4096) // text/event-stream are usually very small messages
	for {
		n, err := response.Body.Read(buf)
		if n > 0 {
			if _, werr := w.Write(buf[:n]); werr != nil {
				return werr
			}
			flusher.Flush() // Flush after each write
		}
		if err != nil {
			if err == io.EOF {
				return nil // End of file, no error
			}
			return err
		}
	}
}

type ExecutePlaywrightCodeRequestObject struct {
	Body *ExecutePlaywrightCodeJSONRequestBody
}

type ExecutePlaywrightCodeResponseObject interface {
	VisitExecutePlaywrightCodeResponse(w http.ResponseWriter) error
}

type ExecutePlaywrightCode200JSONResponse ExecutePlaywrightResult

func (response ExecutePlaywrightCode200JSONResponse) VisitExecutePlaywrightCodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ExecutePlaywrightCode400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ExecutePlaywrightCode400JSONResponse) VisitExecutePlaywrightCodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ExecutePlaywrightCode500JSONResponse struct{ InternalErrorJSONResponse }

func (response ExecutePlaywrightCode500JSONResponse) VisitExecutePlaywrightCodeResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ProcessExecRequestObject struct {
	Body *ProcessExecJSONRequestBody
}

type ProcessExecResponseObject interface {
	VisitProcessExecResponse(w http.ResponseWriter) error
}

type ProcessExec200JSONResponse ProcessExecResult

func (response ProcessExec200JSONResponse) VisitProcessExecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ProcessExec400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ProcessExec400JSONResponse) VisitProcessExecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ProcessExec500JSONResponse struct{ InternalErrorJSONResponse }

func (response ProcessExec500JSONResponse) VisitProcessExecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ProcessSpawnRequestObject struct {
	Body *ProcessSpawnJSONRequestBody
}

type ProcessSpawnResponseObject interface {
	VisitProcessSpawnResponse(w http.ResponseWriter) error
}

type ProcessSpawn200JSONResponse ProcessSpawnResult

func (response ProcessSpawn200JSONResponse) VisitProcessSpawnResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ProcessSpawn400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ProcessSpawn400JSONResponse) VisitProcessSpawnResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ProcessSpawn500JSONResponse struct{ InternalErrorJSONResponse }

func (response ProcessSpawn500JSONResponse) VisitProcessSpawnResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ProcessKillRequestObject struct {
	ProcessId openapi_types.UUID `json:"process_id"`
	Body      *ProcessKillJSONRequestBody
}

type ProcessKillResponseObject interface {
	VisitProcessKillResponse(w http.ResponseWriter) error
}

type ProcessKill200JSONResponse OkResponse

func (response ProcessKill200JSONResponse) VisitProcessKillResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ProcessKill400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ProcessKill400JSONResponse) VisitProcessKillResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ProcessKill404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ProcessKill404JSONResponse) VisitProcessKillResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ProcessKill500JSONResponse struct{ InternalErrorJSONResponse }

func (response ProcessKill500JSONResponse) VisitProcessKillResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStatusRequestObject struct {
	ProcessId openapi_types.UUID `json:"process_id"`
}

type ProcessStatusResponseObject interface {
	VisitProcessStatusResponse(w http.ResponseWriter) error
}

type ProcessStatus200JSONResponse ProcessStatus

func (response ProcessStatus200JSONResponse) VisitProcessStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStatus400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ProcessStatus400JSONResponse) VisitProcessStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStatus404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ProcessStatus404JSONResponse) VisitProcessStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStatus500JSONResponse struct{ InternalErrorJSONResponse }

func (response ProcessStatus500JSONResponse) VisitProcessStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStdinRequestObject struct {
	ProcessId openapi_types.UUID `json:"process_id"`
	Body      *ProcessStdinJSONRequestBody
}

type ProcessStdinResponseObject interface {
	VisitProcessStdinResponse(w http.ResponseWriter) error
}

type ProcessStdin200JSONResponse ProcessStdinResult

func (response ProcessStdin200JSONResponse) VisitProcessStdinResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStdin400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ProcessStdin400JSONResponse) VisitProcessStdinResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStdin404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ProcessStdin404JSONResponse) VisitProcessStdinResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStdin500JSONResponse struct{ InternalErrorJSONResponse }

func (response ProcessStdin500JSONResponse) VisitProcessStdinResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStdoutStreamRequestObject struct {
	ProcessId openapi_types.UUID `json:"process_id"`
}

type ProcessStdoutStreamResponseObject interface {
	VisitProcessStdoutStreamResponse(w http.ResponseWriter) error
}

type ProcessStdoutStream200ResponseHeaders struct {
	XSSEContentType string
}

type ProcessStdoutStream200TexteventStreamResponse struct {
	Body          io.Reader
	Headers       ProcessStdoutStream200ResponseHeaders
	ContentLength int64
}

func (response ProcessStdoutStream200TexteventStreamResponse) VisitProcessStdoutStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/event-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("X-SSE-Content-Type", fmt.Sprint(response.Headers.XSSEContentType))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	flusher, ok := w.(http.Flusher)
	if !ok {
		// If w doesn't support flushing, might as well use io.Copy
		_, err := io.Copy(w, response.Body)
		return err
	}

	// Use a buffer for efficient copying and flushing
	buf := make([]byte, 4096) // text/event-stream are usually very small messages
	for {
		n, err := response.Body.Read(buf)
		if n > 0 {
			if _, werr := w.Write(buf[:n]); werr != nil {
				return werr
			}
			flusher.Flush() // Flush after each write
		}
		if err != nil {
			if err == io.EOF {
				return nil // End of file, no error
			}
			return err
		}
	}
}

type ProcessStdoutStream400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response ProcessStdoutStream400JSONResponse) VisitProcessStdoutStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStdoutStream404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response ProcessStdoutStream404JSONResponse) VisitProcessStdoutStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ProcessStdoutStream500JSONResponse struct{ InternalErrorJSONResponse }

func (response ProcessStdoutStream500JSONResponse) VisitProcessStdoutStreamResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteRecordingRequestObject struct {
	Body *DeleteRecordingJSONRequestBody
}

type DeleteRecordingResponseObject interface {
	VisitDeleteRecordingResponse(w http.ResponseWriter) error
}

type DeleteRecording200Response struct {
}

func (response DeleteRecording200Response) VisitDeleteRecordingResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type DeleteRecording400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DeleteRecording400JSONResponse) VisitDeleteRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteRecording404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DeleteRecording404JSONResponse) VisitDeleteRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteRecording500JSONResponse struct{ InternalErrorJSONResponse }

func (response DeleteRecording500JSONResponse) VisitDeleteRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DownloadRecordingRequestObject struct {
	Params DownloadRecordingParams
}

type DownloadRecordingResponseObject interface {
	VisitDownloadRecordingResponse(w http.ResponseWriter) error
}

type DownloadRecording200ResponseHeaders struct {
	XRecordingFinishedAt string
	XRecordingStartedAt  string
}

type DownloadRecording200Videomp4Response struct {
	Body          io.Reader
	Headers       DownloadRecording200ResponseHeaders
	ContentLength int64
}

func (response DownloadRecording200Videomp4Response) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "video/mp4")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("X-Recording-Finished-At", fmt.Sprint(response.Headers.XRecordingFinishedAt))
	w.Header().Set("X-Recording-Started-At", fmt.Sprint(response.Headers.XRecordingStartedAt))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DownloadRecording202ResponseHeaders struct {
	RetryAfter int
}

type DownloadRecording202Response struct {
	Headers DownloadRecording202ResponseHeaders
}

func (response DownloadRecording202Response) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Retry-After", fmt.Sprint(response.Headers.RetryAfter))
	w.WriteHeader(202)
	return nil
}

type DownloadRecording400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response DownloadRecording400JSONResponse) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DownloadRecording404JSONResponse struct{ NotFoundErrorJSONResponse }

func (response DownloadRecording404JSONResponse) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DownloadRecording500JSONResponse struct{ InternalErrorJSONResponse }

func (response DownloadRecording500JSONResponse) VisitDownloadRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListRecordersRequestObject struct {
}

type ListRecordersResponseObject interface {
	VisitListRecordersResponse(w http.ResponseWriter) error
}

type ListRecorders200JSONResponse []RecorderInfo

func (response ListRecorders200JSONResponse) VisitListRecordersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListRecorders500JSONResponse struct{ InternalErrorJSONResponse }

func (response ListRecorders500JSONResponse) VisitListRecordersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type StartRecordingRequestObject struct {
	Body *StartRecordingJSONRequestBody
}

type StartRecordingResponseObject interface {
	VisitStartRecordingResponse(w http.ResponseWriter) error
}

type StartRecording201Response struct {
}

func (response StartRecording201Response) VisitStartRecordingResponse(w http.ResponseWriter) error {
	w.WriteHeader(201)
	return nil
}

type StartRecording400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response StartRecording400JSONResponse) VisitStartRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type StartRecording409JSONResponse struct{ ConflictErrorJSONResponse }

func (response StartRecording409JSONResponse) VisitStartRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type StartRecording500JSONResponse struct{ InternalErrorJSONResponse }

func (response StartRecording500JSONResponse) VisitStartRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type StopRecordingRequestObject struct {
	Body *StopRecordingJSONRequestBody
}

type StopRecordingResponseObject interface {
	VisitStopRecordingResponse(w http.ResponseWriter) error
}

type StopRecording200Response struct {
}

func (response StopRecording200Response) VisitStopRecordingResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type StopRecording400JSONResponse struct{ BadRequestErrorJSONResponse }

func (response StopRecording400JSONResponse) VisitStopRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type StopRecording500JSONResponse struct{ InternalErrorJSONResponse }

func (response StopRecording500JSONResponse) VisitStopRecordingResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Update Chromium launch flags and restart
	// (PATCH /chromium/flags)
	PatchChromiumFlags(ctx context.Context, request PatchChromiumFlagsRequestObject) (PatchChromiumFlagsResponseObject, error)
	// Upload one or more unpacked extensions (as zips) and restart Chromium
	// (POST /chromium/upload-extensions-and-restart)
	UploadExtensionsAndRestart(ctx context.Context, request UploadExtensionsAndRestartRequestObject) (UploadExtensionsAndRestartResponseObject, error)
	// Simulate a mouse click action on the host computer
	// (POST /computer/click_mouse)
	ClickMouse(ctx context.Context, request ClickMouseRequestObject) (ClickMouseResponseObject, error)
	// Hide or show the cursor
	// (POST /computer/cursor)
	SetCursor(ctx context.Context, request SetCursorRequestObject) (SetCursorResponseObject, error)
	// Drag the mouse along a path
	// (POST /computer/drag_mouse)
	DragMouse(ctx context.Context, request DragMouseRequestObject) (DragMouseResponseObject, error)
	// Move the mouse cursor to the specified coordinates on the host computer
	// (POST /computer/move_mouse)
	MoveMouse(ctx context.Context, request MoveMouseRequestObject) (MoveMouseResponseObject, error)
	// Press one or more keys on the host computer
	// (POST /computer/press_key)
	PressKey(ctx context.Context, request PressKeyRequestObject) (PressKeyResponseObject, error)
	// Capture a screenshot of the host computer
	// (POST /computer/screenshot)
	TakeScreenshot(ctx context.Context, request TakeScreenshotRequestObject) (TakeScreenshotResponseObject, error)
	// Scroll the mouse wheel at a position on the host computer
	// (POST /computer/scroll)
	Scroll(ctx context.Context, request ScrollRequestObject) (ScrollResponseObject, error)
	// Type text on the host computer
	// (POST /computer/type)
	TypeText(ctx context.Context, request TypeTextRequestObject) (TypeTextResponseObject, error)
	// Run performance benchmarks
	// (GET /dev/benchmark)
	RunBenchmark(ctx context.Context, request RunBenchmarkRequestObject) (RunBenchmarkResponseObject, error)
	// Update display configuration
	// (PATCH /display)
	PatchDisplay(ctx context.Context, request PatchDisplayRequestObject) (PatchDisplayResponseObject, error)
	// Create a new directory
	// (PUT /fs/create_directory)
	CreateDirectory(ctx context.Context, request CreateDirectoryRequestObject) (CreateDirectoryResponseObject, error)
	// Delete a directory
	// (PUT /fs/delete_directory)
	DeleteDirectory(ctx context.Context, request DeleteDirectoryRequestObject) (DeleteDirectoryResponseObject, error)
	// Delete a file
	// (PUT /fs/delete_file)
	DeleteFile(ctx context.Context, request DeleteFileRequestObject) (DeleteFileResponseObject, error)
	// Download a directory as a ZIP archive
	// (GET /fs/download_dir_zip)
	DownloadDirZip(ctx context.Context, request DownloadDirZipRequestObject) (DownloadDirZipResponseObject, error)
	// Get information about a file or directory
	// (GET /fs/file_info)
	FileInfo(ctx context.Context, request FileInfoRequestObject) (FileInfoResponseObject, error)
	// List files in a directory
	// (GET /fs/list_files)
	ListFiles(ctx context.Context, request ListFilesRequestObject) (ListFilesResponseObject, error)
	// Move or rename a file or directory
	// (PUT /fs/move)
	MovePath(ctx context.Context, request MovePathRequestObject) (MovePathResponseObject, error)
	// Read file contents
	// (GET /fs/read_file)
	ReadFile(ctx context.Context, request ReadFileRequestObject) (ReadFileResponseObject, error)
	// Set file or directory permissions/ownership
	// (PUT /fs/set_file_permissions)
	SetFilePermissions(ctx context.Context, request SetFilePermissionsRequestObject) (SetFilePermissionsResponseObject, error)
	// Upload one or more files
	// (POST /fs/upload)
	UploadFiles(ctx context.Context, request UploadFilesRequestObject) (UploadFilesResponseObject, error)
	// Upload a zip archive and extract it
	// (POST /fs/upload_zip)
	UploadZip(ctx context.Context, request UploadZipRequestObject) (UploadZipResponseObject, error)
	// Watch a directory for changes
	// (POST /fs/watch)
	StartFsWatch(ctx context.Context, request StartFsWatchRequestObject) (StartFsWatchResponseObject, error)
	// Stop watching a directory
	// (DELETE /fs/watch/{watch_id})
	StopFsWatch(ctx context.Context, request StopFsWatchRequestObject) (StopFsWatchResponseObject, error)
	// Stream filesystem events for a watch
	// (GET /fs/watch/{watch_id}/events)
	StreamFsEvents(ctx context.Context, request StreamFsEventsRequestObject) (StreamFsEventsResponseObject, error)
	// Write or create a file
	// (PUT /fs/write_file)
	WriteFile(ctx context.Context, request WriteFileRequestObject) (WriteFileResponseObject, error)
	// Stream logs over SSE
	// (GET /logs/stream)
	LogsStream(ctx context.Context, request LogsStreamRequestObject) (LogsStreamResponseObject, error)
	// Execute Playwright/TypeScript code against the browser
	// (POST /playwright/execute)
	ExecutePlaywrightCode(ctx context.Context, request ExecutePlaywrightCodeRequestObject) (ExecutePlaywrightCodeResponseObject, error)
	// Execute a command synchronously
	// (POST /process/exec)
	ProcessExec(ctx context.Context, request ProcessExecRequestObject) (ProcessExecResponseObject, error)
	// Execute a command asynchronously
	// (POST /process/spawn)
	ProcessSpawn(ctx context.Context, request ProcessSpawnRequestObject) (ProcessSpawnResponseObject, error)
	// Send signal to process
	// (POST /process/{process_id}/kill)
	ProcessKill(ctx context.Context, request ProcessKillRequestObject) (ProcessKillResponseObject, error)
	// Get process status
	// (GET /process/{process_id}/status)
	ProcessStatus(ctx context.Context, request ProcessStatusRequestObject) (ProcessStatusResponseObject, error)
	// Write to process stdin
	// (POST /process/{process_id}/stdin)
	ProcessStdin(ctx context.Context, request ProcessStdinRequestObject) (ProcessStdinResponseObject, error)
	// Stream process stdout over SSE
	// (GET /process/{process_id}/stdout/stream)
	ProcessStdoutStream(ctx context.Context, request ProcessStdoutStreamRequestObject) (ProcessStdoutStreamResponseObject, error)
	// Delete a previously recorded video file
	// (POST /recording/delete)
	DeleteRecording(ctx context.Context, request DeleteRecordingRequestObject) (DeleteRecordingResponseObject, error)
	// Download the most recently recorded video file
	// (GET /recording/download)
	DownloadRecording(ctx context.Context, request DownloadRecordingRequestObject) (DownloadRecordingResponseObject, error)
	// List all recorders
	// (GET /recording/list)
	ListRecorders(ctx context.Context, request ListRecordersRequestObject) (ListRecordersResponseObject, error)
	// Start a screen recording. Only one recording per ID can be registered at a time.
	// (POST /recording/start)
	StartRecording(ctx context.Context, request StartRecordingRequestObject) (StartRecordingResponseObject, error)
	// Stop the recording
	// (POST /recording/stop)
	StopRecording(ctx context.Context, request StopRecordingRequestObject) (StopRecordingResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// PatchChromiumFlags operation middleware
func (sh *strictHandler) PatchChromiumFlags(w http.ResponseWriter, r *http.Request) {
	var request PatchChromiumFlagsRequestObject

	var body PatchChromiumFlagsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PatchChromiumFlags(ctx, request.(PatchChromiumFlagsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PatchChromiumFlags")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PatchChromiumFlagsResponseObject); ok {
		if err := validResponse.VisitPatchChromiumFlagsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UploadExtensionsAndRestart operation middleware
func (sh *strictHandler) UploadExtensionsAndRestart(w http.ResponseWriter, r *http.Request) {
	var request UploadExtensionsAndRestartRequestObject

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UploadExtensionsAndRestart(ctx, request.(UploadExtensionsAndRestartRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadExtensionsAndRestart")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UploadExtensionsAndRestartResponseObject); ok {
		if err := validResponse.VisitUploadExtensionsAndRestartResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ClickMouse operation middleware
func (sh *strictHandler) ClickMouse(w http.ResponseWriter, r *http.Request) {
	var request ClickMouseRequestObject

	var body ClickMouseJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ClickMouse(ctx, request.(ClickMouseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ClickMouse")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ClickMouseResponseObject); ok {
		if err := validResponse.VisitClickMouseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SetCursor operation middleware
func (sh *strictHandler) SetCursor(w http.ResponseWriter, r *http.Request) {
	var request SetCursorRequestObject

	var body SetCursorJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SetCursor(ctx, request.(SetCursorRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SetCursor")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SetCursorResponseObject); ok {
		if err := validResponse.VisitSetCursorResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DragMouse operation middleware
func (sh *strictHandler) DragMouse(w http.ResponseWriter, r *http.Request) {
	var request DragMouseRequestObject

	var body DragMouseJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DragMouse(ctx, request.(DragMouseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DragMouse")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DragMouseResponseObject); ok {
		if err := validResponse.VisitDragMouseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// MoveMouse operation middleware
func (sh *strictHandler) MoveMouse(w http.ResponseWriter, r *http.Request) {
	var request MoveMouseRequestObject

	var body MoveMouseJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.MoveMouse(ctx, request.(MoveMouseRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "MoveMouse")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(MoveMouseResponseObject); ok {
		if err := validResponse.VisitMoveMouseResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PressKey operation middleware
func (sh *strictHandler) PressKey(w http.ResponseWriter, r *http.Request) {
	var request PressKeyRequestObject

	var body PressKeyJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PressKey(ctx, request.(PressKeyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PressKey")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PressKeyResponseObject); ok {
		if err := validResponse.VisitPressKeyResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// TakeScreenshot operation middleware
func (sh *strictHandler) TakeScreenshot(w http.ResponseWriter, r *http.Request) {
	var request TakeScreenshotRequestObject

	var body TakeScreenshotJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.TakeScreenshot(ctx, request.(TakeScreenshotRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "TakeScreenshot")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(TakeScreenshotResponseObject); ok {
		if err := validResponse.VisitTakeScreenshotResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Scroll operation middleware
func (sh *strictHandler) Scroll(w http.ResponseWriter, r *http.Request) {
	var request ScrollRequestObject

	var body ScrollJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.Scroll(ctx, request.(ScrollRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "Scroll")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ScrollResponseObject); ok {
		if err := validResponse.VisitScrollResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// TypeText operation middleware
func (sh *strictHandler) TypeText(w http.ResponseWriter, r *http.Request) {
	var request TypeTextRequestObject

	var body TypeTextJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.TypeText(ctx, request.(TypeTextRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "TypeText")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(TypeTextResponseObject); ok {
		if err := validResponse.VisitTypeTextResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RunBenchmark operation middleware
func (sh *strictHandler) RunBenchmark(w http.ResponseWriter, r *http.Request, params RunBenchmarkParams) {
	var request RunBenchmarkRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RunBenchmark(ctx, request.(RunBenchmarkRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RunBenchmark")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RunBenchmarkResponseObject); ok {
		if err := validResponse.VisitRunBenchmarkResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PatchDisplay operation middleware
func (sh *strictHandler) PatchDisplay(w http.ResponseWriter, r *http.Request) {
	var request PatchDisplayRequestObject

	var body PatchDisplayJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PatchDisplay(ctx, request.(PatchDisplayRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PatchDisplay")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PatchDisplayResponseObject); ok {
		if err := validResponse.VisitPatchDisplayResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateDirectory operation middleware
func (sh *strictHandler) CreateDirectory(w http.ResponseWriter, r *http.Request) {
	var request CreateDirectoryRequestObject

	var body CreateDirectoryJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CreateDirectory(ctx, request.(CreateDirectoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateDirectory")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CreateDirectoryResponseObject); ok {
		if err := validResponse.VisitCreateDirectoryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteDirectory operation middleware
func (sh *strictHandler) DeleteDirectory(w http.ResponseWriter, r *http.Request) {
	var request DeleteDirectoryRequestObject

	var body DeleteDirectoryJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteDirectory(ctx, request.(DeleteDirectoryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteDirectory")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteDirectoryResponseObject); ok {
		if err := validResponse.VisitDeleteDirectoryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteFile operation middleware
func (sh *strictHandler) DeleteFile(w http.ResponseWriter, r *http.Request) {
	var request DeleteFileRequestObject

	var body DeleteFileJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteFile(ctx, request.(DeleteFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteFile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteFileResponseObject); ok {
		if err := validResponse.VisitDeleteFileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DownloadDirZip operation middleware
func (sh *strictHandler) DownloadDirZip(w http.ResponseWriter, r *http.Request, params DownloadDirZipParams) {
	var request DownloadDirZipRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DownloadDirZip(ctx, request.(DownloadDirZipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DownloadDirZip")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DownloadDirZipResponseObject); ok {
		if err := validResponse.VisitDownloadDirZipResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// FileInfo operation middleware
func (sh *strictHandler) FileInfo(w http.ResponseWriter, r *http.Request, params FileInfoParams) {
	var request FileInfoRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.FileInfo(ctx, request.(FileInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "FileInfo")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(FileInfoResponseObject); ok {
		if err := validResponse.VisitFileInfoResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListFiles operation middleware
func (sh *strictHandler) ListFiles(w http.ResponseWriter, r *http.Request, params ListFilesParams) {
	var request ListFilesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListFiles(ctx, request.(ListFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListFiles")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListFilesResponseObject); ok {
		if err := validResponse.VisitListFilesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// MovePath operation middleware
func (sh *strictHandler) MovePath(w http.ResponseWriter, r *http.Request) {
	var request MovePathRequestObject

	var body MovePathJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.MovePath(ctx, request.(MovePathRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "MovePath")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(MovePathResponseObject); ok {
		if err := validResponse.VisitMovePathResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ReadFile operation middleware
func (sh *strictHandler) ReadFile(w http.ResponseWriter, r *http.Request, params ReadFileParams) {
	var request ReadFileRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ReadFile(ctx, request.(ReadFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ReadFile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ReadFileResponseObject); ok {
		if err := validResponse.VisitReadFileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SetFilePermissions operation middleware
func (sh *strictHandler) SetFilePermissions(w http.ResponseWriter, r *http.Request) {
	var request SetFilePermissionsRequestObject

	var body SetFilePermissionsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SetFilePermissions(ctx, request.(SetFilePermissionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SetFilePermissions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SetFilePermissionsResponseObject); ok {
		if err := validResponse.VisitSetFilePermissionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UploadFiles operation middleware
func (sh *strictHandler) UploadFiles(w http.ResponseWriter, r *http.Request) {
	var request UploadFilesRequestObject

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UploadFiles(ctx, request.(UploadFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadFiles")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UploadFilesResponseObject); ok {
		if err := validResponse.VisitUploadFilesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UploadZip operation middleware
func (sh *strictHandler) UploadZip(w http.ResponseWriter, r *http.Request) {
	var request UploadZipRequestObject

	if reader, err := r.MultipartReader(); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode multipart body: %w", err))
		return
	} else {
		request.Body = reader
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UploadZip(ctx, request.(UploadZipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadZip")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UploadZipResponseObject); ok {
		if err := validResponse.VisitUploadZipResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StartFsWatch operation middleware
func (sh *strictHandler) StartFsWatch(w http.ResponseWriter, r *http.Request) {
	var request StartFsWatchRequestObject

	var body StartFsWatchJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StartFsWatch(ctx, request.(StartFsWatchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StartFsWatch")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StartFsWatchResponseObject); ok {
		if err := validResponse.VisitStartFsWatchResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StopFsWatch operation middleware
func (sh *strictHandler) StopFsWatch(w http.ResponseWriter, r *http.Request, watchId string) {
	var request StopFsWatchRequestObject

	request.WatchId = watchId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StopFsWatch(ctx, request.(StopFsWatchRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StopFsWatch")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StopFsWatchResponseObject); ok {
		if err := validResponse.VisitStopFsWatchResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StreamFsEvents operation middleware
func (sh *strictHandler) StreamFsEvents(w http.ResponseWriter, r *http.Request, watchId string) {
	var request StreamFsEventsRequestObject

	request.WatchId = watchId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StreamFsEvents(ctx, request.(StreamFsEventsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StreamFsEvents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StreamFsEventsResponseObject); ok {
		if err := validResponse.VisitStreamFsEventsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WriteFile operation middleware
func (sh *strictHandler) WriteFile(w http.ResponseWriter, r *http.Request, params WriteFileParams) {
	var request WriteFileRequestObject

	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WriteFile(ctx, request.(WriteFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WriteFile")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WriteFileResponseObject); ok {
		if err := validResponse.VisitWriteFileResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// LogsStream operation middleware
func (sh *strictHandler) LogsStream(w http.ResponseWriter, r *http.Request, params LogsStreamParams) {
	var request LogsStreamRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.LogsStream(ctx, request.(LogsStreamRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "LogsStream")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LogsStreamResponseObject); ok {
		if err := validResponse.VisitLogsStreamResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ExecutePlaywrightCode operation middleware
func (sh *strictHandler) ExecutePlaywrightCode(w http.ResponseWriter, r *http.Request) {
	var request ExecutePlaywrightCodeRequestObject

	var body ExecutePlaywrightCodeJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ExecutePlaywrightCode(ctx, request.(ExecutePlaywrightCodeRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ExecutePlaywrightCode")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ExecutePlaywrightCodeResponseObject); ok {
		if err := validResponse.VisitExecutePlaywrightCodeResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessExec operation middleware
func (sh *strictHandler) ProcessExec(w http.ResponseWriter, r *http.Request) {
	var request ProcessExecRequestObject

	var body ProcessExecJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessExec(ctx, request.(ProcessExecRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessExec")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessExecResponseObject); ok {
		if err := validResponse.VisitProcessExecResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessSpawn operation middleware
func (sh *strictHandler) ProcessSpawn(w http.ResponseWriter, r *http.Request) {
	var request ProcessSpawnRequestObject

	var body ProcessSpawnJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessSpawn(ctx, request.(ProcessSpawnRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessSpawn")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessSpawnResponseObject); ok {
		if err := validResponse.VisitProcessSpawnResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessKill operation middleware
func (sh *strictHandler) ProcessKill(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID) {
	var request ProcessKillRequestObject

	request.ProcessId = processId

	var body ProcessKillJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessKill(ctx, request.(ProcessKillRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessKill")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessKillResponseObject); ok {
		if err := validResponse.VisitProcessKillResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessStatus operation middleware
func (sh *strictHandler) ProcessStatus(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID) {
	var request ProcessStatusRequestObject

	request.ProcessId = processId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessStatus(ctx, request.(ProcessStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessStatus")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessStatusResponseObject); ok {
		if err := validResponse.VisitProcessStatusResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessStdin operation middleware
func (sh *strictHandler) ProcessStdin(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID) {
	var request ProcessStdinRequestObject

	request.ProcessId = processId

	var body ProcessStdinJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessStdin(ctx, request.(ProcessStdinRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessStdin")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessStdinResponseObject); ok {
		if err := validResponse.VisitProcessStdinResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ProcessStdoutStream operation middleware
func (sh *strictHandler) ProcessStdoutStream(w http.ResponseWriter, r *http.Request, processId openapi_types.UUID) {
	var request ProcessStdoutStreamRequestObject

	request.ProcessId = processId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ProcessStdoutStream(ctx, request.(ProcessStdoutStreamRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ProcessStdoutStream")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ProcessStdoutStreamResponseObject); ok {
		if err := validResponse.VisitProcessStdoutStreamResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteRecording operation middleware
func (sh *strictHandler) DeleteRecording(w http.ResponseWriter, r *http.Request) {
	var request DeleteRecordingRequestObject

	var body DeleteRecordingJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteRecording(ctx, request.(DeleteRecordingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteRecording")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteRecordingResponseObject); ok {
		if err := validResponse.VisitDeleteRecordingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DownloadRecording operation middleware
func (sh *strictHandler) DownloadRecording(w http.ResponseWriter, r *http.Request, params DownloadRecordingParams) {
	var request DownloadRecordingRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DownloadRecording(ctx, request.(DownloadRecordingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DownloadRecording")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DownloadRecordingResponseObject); ok {
		if err := validResponse.VisitDownloadRecordingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListRecorders operation middleware
func (sh *strictHandler) ListRecorders(w http.ResponseWriter, r *http.Request) {
	var request ListRecordersRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListRecorders(ctx, request.(ListRecordersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListRecorders")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListRecordersResponseObject); ok {
		if err := validResponse.VisitListRecordersResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StartRecording operation middleware
func (sh *strictHandler) StartRecording(w http.ResponseWriter, r *http.Request) {
	var request StartRecordingRequestObject

	var body StartRecordingJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StartRecording(ctx, request.(StartRecordingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StartRecording")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StartRecordingResponseObject); ok {
		if err := validResponse.VisitStartRecordingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StopRecording operation middleware
func (sh *strictHandler) StopRecording(w http.ResponseWriter, r *http.Request) {
	var request StopRecordingRequestObject

	var body StopRecordingJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StopRecording(ctx, request.(StopRecordingRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StopRecording")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StopRecordingResponseObject); ok {
		if err := validResponse.VisitStopRecordingResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9e3MbN/LgV0HxtsrWLR/yK3vx1v3hWPJGv9ixSnI2e4l8/EEzTRKrGWACYEjRLn/3",
	"KzSAeWI4Q8qK7a2r2trIHKABdDca/ULj4ygSaSY4cK1Gzz+OJKhMcAX4jx9ofAF/5KD0qZRCmp8iwTVw",
	"bf6kWZawiGom+OzfSnDzm4pWkFLz118kLEbPR/9jVsKf2a9qZqF9+vRpPIpBRZJlBsjouRmQuBFHn8aj",
	"l4IvEhb9WaP74czQZ1yD5DT5k4b2w5FLkGuQxDUcj34W+pXIefwnzeNnoQmONzLfXHNkBeDRKqXy5gJU",
	"nlheoXHMTD+anEuRgdTMsM2CJgqacM9BLoRMKY+AXHtQRFpY0ys+Go+yCoyPI0hopiCeK4gEj/GnOsQX",
	"kc5pQlw7olkKhHHi2pOFkIQmSTmYIloQg4oENIzGI73NYPR8xPP0GhDTYHASGAhxpQjwSOSGShCTOJeM",
	"L0vYjC/tGpiGFEE46Eqbhga6+4FKSbfm37JE4y5CvfQ/ebQbqmgqdZ7NNUsN8B4Il7b1O2xchbJVGtLe",
	"3tjqjC8ELoKloDRNszaWfl0BJ3pVpe6GKiJzgxYkvR49H8VUw8RAKQngUVTiSFz/G+wm/IFpSTW8AS1Z",
	"1M9ydQ6iecxEgG/Mz+TaQjYcc3OdqRA/aKFp0u7/zvw8pP+axRAY/5/m5/7+IXS8PDk/5XEmWMkO++1C",
	"18tuDqIyiNiCReTlyTkBB5g8zKS4ZRATIUnMJET6qL05XeN5LgMYqoH75eJ1m9ZGsgCnkonAfjsHOfGf",
	"vYTAGesVUwXg6mbbuYFOzi8dMLv60GZUoBQTfL6gLMklBCZ1aVsooldUE9OuFAMKdJ6Rh5EEqmFGtabR",
	"asbpmi1RNB+V62dcw9JyhxtSzXE3QxwYMo8iUGqRJ8mWZBIyakSPQa7vSx5mICceI+FxkIvneiVFvlxl",
	"uZ6LTM0zkEawdjG3ITVOXZEMpBOphEZSKIVCtaReiG8l/JEzaZb0e51TemZT5Yr3YfY/l+J2exjvG8QZ",
	"1t62zx88FijS0nI8WSvit4FfgWrtgkjwKJcSuJ5HgnOIEGVtpP6MqCFiQcoepNKD5OYAY7ycWJCSdmrz",
	"YgP0M35TWHwaj1JIhdzO0+u+7m+woZe8n3DtBh93HB8pMBdrkCugsSF95JSZbn3BtzYYtBSkyJimJ10C",
	"eZgJxTRbA/nfRCViA0ZUIIfZ5keDpWtDUnw24apB6WLTtPiIag1pZpgoD6HC7knXSBGmVA5xKRArYNs8",
	"E1ENSyG3AeniJaxvQh7CdDkdk4ucmwN6TE7evhmTc7qEMfkZ9EbImzGpkOUoJNZrYzSH/DFPKZ9IoDG9",
	"ToBUPhrKGt2hvZYK6NzKpG6N8FeaJJMoEdGN1QZVZjaazDk3O7uJrEInWSSC6k6FcK6oURlDRwJ+MFPP",
	"OfsjB4LtSQpK0SXsVhj3UhXdqdTFH6V4ccdSwSrDeCShGni0nfefpa9ty4pQ4DSFHbxlPjf4agprmuRU",
	"WwabLkGfiChPoXZ+lbgojqL+1avivGwcYIbSVsD2I8MBmRvlrPNIJqi6VSXQ8eTR8fFRUIscePK+DZ65",
	"Oyi4U5QlLLp5I3IF3pjeT3W+zrUO7WAESexXY04ZxEkaabJhejUaj4DnqTn1E1iYHSXZcmX+m7I4TozK",
	"f02jG7v1NlTGlUO+JHhkpj63P7ck4TbD/YZtCMXTszJqLDbmn3k2cmCCA6xEEs9vYKtCy4vZgoEk5rNZ",
	"n2nr966RTxbqPnuX5+kce7nhFhQPlkfjTjZGG8sMLiEDqmvjtvn1tr2Kf5FICBkzbpjUCVaLMXtOIs7a",
	"kAJnxP85BFJDAbwdGdBBdU7EEA017ZqOmhgiwriV4XYeexh/EXZ3cglbzkSWq6AA2mnF1QBhy9k/z//X",
	"0TDjtmXaH6huSJESxmO2ZnFOKw4PUkrwkIMlirMBKlxN4UbSRsgRvW6HC9+w0nkD11JH84StYb5msOmD",
	"8StcX7x7+Zqt4Z8MNgWgIDLR+DpBFVnI7WFiLxUxhCSz7e5sA6MqmYbkoYiMYmZJPCaGCcjfnj07mpIT",
	"u81xF//t2bOpwb05lKUB939/P5787f3HJ+Onn/4SYriM6lWAca+VSHINlUmYhujTwqU3BplN/2eQC6tb",
	"E0cK7cwTSEDDOdWrw/DYswQ/8RiH+fwTr7DeIbNnAVv8LAau7dng5GCxESorIS+SbEV5noJkERGSrLbZ",
	"CniT/nTy4cXkt+PJ95P3f/3LMFlxwlSW0O1LwRdsued6VoDHcNtN4yzR2MImtp1RkzJ2C4kKnhISFhLU",
	"qkM/aoJ0rYl3df34gTxMqbHACc+ThLAF4UKTGDRE2hgFYR/GhsUhhmqOhs12zj+IWkmXf4KqFEu67FCT",
	"CvXI6kvvg3ZVQrc1DeK4eR6cmCZm9SlLEubd4NegNwDcT8SoSITymKDXyXFvKtZAaCKckmN21xSnxVlq",
	"Jnocosld1CiDi720qLBAeStjNK4SprTZlr/fjsn2fVVnySiTqliidwpsViyxk1gyvpySN7lCf4ymjBOq",
	"SQJUafKYWLfPtDrT5pQrCEnp7Zn9+hhxV/6juZqdH5WGbI7kdgZZQfFne5JcQkLRK2JAqsaqyUOz8Qwx",
	"GGeamdPNADvqJzxCc3bMMi2cN16xPe7WbIsJITXsrKytg3Csgeb4j7yxkyCPajN61Ktvdp4NRQCtceZb",
	"cz3Ahg3AvmEQ9i1EuYbzhG43uImHypKmSoe9DMOChUhKkKhsBnyQcYehdIn/nv0XXVP7JwKowJ6Sd0af",
	"Nz+uqCLUmrZakAcZXcKDMXmAocZb/WCMIuPBtRQbBfIBWVPJjLQ2euXpLbpBnpOrEd1QponpPF0KLR4+",
	"WGmdqeezGdg200ikD47+TiToXHJSaa6ZTuDh0d+vRlc8pBMZm0jkurScHbd91+K2N/QW2caukRnZWw8M",
	"FtoZYYp8d4zcZfuMnj85Pt6L1xD5A/nhYIei2TkNLihX147MeC4PxDC9a8ocuyV+rNMohHVZTLrBXSsg",
	"a5rk4CgJMbneWuMQ9WK2IJRvj6ywiEEG5nOpKY+pjJ3PDG0YA6C6sHbMSMci1zuAiVxnuR4KzfpygpFM",
	"vUIfMlSxDXHFw5RsS5DXQiRAeYs7/AAhBnnFEsCgakseMTWPmdw9K1SgmSK0tAamgfmMjUEzx2hrC9xr",
	"c8SleFDbBALcJ9OBsdpxh6lklmWNo2umlTeMr0ax3NzKifnf1cjoxVejidxM5MT872p0NA2NEHYt/kAV",
	"WLei08MXZsgiVFnHxGCjyqs8bSZhH2B+vdVB/y/7gIIFP0/JMTrr/DQYqGm/cwTX6GZXG2zs+aBCQ4f0",
	"LnaykfrTdTCcYhrYgD+JVpQvgYBpOG3JjyHsRxcLiMx+GMyHh9KyGOpQou7HJWGvI6KUmG/Tiu7+8uL0",
	"xbvT0Xj068UZ/vfk9PUp/nFx+vOLN6cBNb5BfPw67lZYXkmawmH+MexqdHzNlGaRjQRYb4p1UwX0CCnz",
	"LBiHfuk/kYUBG7YLYzCiMtAbp6KI/x7sK0WW7errvof63sB2bqc175zCT7B1U985DQkRsHUIgI3AORBF",
	"s2HmJa7h4vAklmjFwE2qFVtI6W34d8aDv2sql6ADn0IT/y+mNcjD+M/2JSlQlUswyr1qmin7eWz/bQEa",
	"GPvn2uzuHFp7I9C1p/fr2XEQ+9n3zzp+/34gSV4zpVGSB9Bk7EeMAbZkaMVNToBrfzQNyp4p9JSAUf5a",
	"LDtOmxckEUsca1sqY5VkxfaxU7HCGnqKWBZqq7FFpl3mQUda2juj/ZvhyxltKCZ3xHlkz5WByWkhW7A6",
	"dEiE15Mo9nQsUQUJ4xDmGZCVnJPOJmsGG5ADueuNWMMdHGF3cQilYg17OYT6wl6lywdIlEslJNHioLDX",
	"UEiDw14GzYe71mNQet4XIgClzeTNhveabZ+HfTxSMuoDrEQuIxgMs2kP+QHGlVWEMOSyTQ47elznSQJr",
	"SEjqYLQOmzVlCb1OYC5yvRSML+cuI3OO6ZhtHPgOxHcYkgKKyvy8T7HAVrv0Cg9IQXd+kAWCLYLKjdaF",
	"P7HmYxA5jydasqxwlDRO6QGS4+3Nhbs1sCex/gEcQyVvfyL+3kH7bBA3NZ+Pljm0s+djc7QYBFije9pv",
	"noubIPOd0+gG9GG8Z/t26N1KS6Bph94zT4TqTv1CFShD4IpgyxCJLaA+ZqsD28l0iVCqO0Pv7RokTRIH",
	"ykyrmpTXqaTtXCm26F+pBdS30jqwPdX2c6qjlYu6HXgedoTdTrrDbYXr8fHT4/2DbyedQbcpOVsQkRo1",
	"OB6TXIHC42zFlitQmhTC0HaxOUdgdqQR+05fc3bvd8fjJ8fjx8/Gj47fh6eIO2zO4gT6t+2C4M9myrkC",
	"m/Si2AcgmxVwkrA1EKPCGH22iLfOJOAymcIMoDWEXQ4SMMQ1j1ZSpCxPAzHdcnRsSl66poQujL1Qrt/7",
	"TLQgwI1FQ5gmNKaZDfFz2BAz65prGXkCcbkCGi/yZIyjFb8kHVKqM9p50hnlLNjmyePjgdy9okbNO8An",
	"ba+RkJhq6hNdGV8mQNylFJIZ0C0hVyRvhs6gE/fROmuYsjD6j6Iuv9LPFZdSc1ptJ1IpskJJyD7Dz4AT",
	"Nt3DAqzbCbtOR0T2ZZ6m1Obh7oFt16t5otQW1T5RFlRpo2D14dq1G45uD9gicyfea7CD6mYiNkMm6doN",
	"n6QHPGCSNdjDEjHOJSj1Exx4Jvht0BPJ98v3lpKZK5pOGL5v4KAq3I2gPB7btlQC0TTLrJF7cDC/yH5K",
	"+4y4G8BrKspooX/kwCOY7mXThcd/7YL7BrraptciwcFxoCk5pdGKmCGIWok8ick1EFppS1SeZUJqG6K6",
	"jYUWIrniDxUA+dejR7iWbUpiWGAYXHB1NCUupKkI41GSx0CuRhcY6LoajcnV6HLFFtr++VLLxP71InE/",
	"vXp2NZpe2QB/kXKMGQoRTpAmSphZRiK9dkaacsljFt5ftY+R4L9wtL++o9cIdg+ENtRdxG5Q4ZXCaMyn",
	"txB9tqg1NctLMc9ky80JzEWukm1bt6dyWU9y+P19O9fTQqJyiWniaj+uomouhagnKYSXkbv0A4sPzNUh",
	"pivJJFuzBJbQcWBTNc8VBIImTZBUWXYwrQ0onieod3ntqJ0MbdceiEkgoq09KolaQZIUKDdaVM6DjrJo",
	"E4D1q8ALrBWP4UNajaEcOYguIGoHYTy0gH4vA/B1N3t9DCU+OZp9bF1VPuVrJgXH1JEiI8HMVYEulFiH",
	"+go2Ss5vZRXsl0jQTcDufAFLzt5teKdkAVrddAXBinVM91POTov1+2atAyhoo8Et0/NwdopbKjFNMMIe",
	"hmBzB+bX3z0Nhw6/ezoBjuEcYpuS63yxsDurI3dgKDCR625gn7qp9xNLksOE6CVbmkMWudfu4Qb31kmm",
	"sHlNqI3enV68Ge2GWw1guuY/nb1+PRqPzn5+NxqPfvzlvD9u6cbewcSXGd3wKh6S5O1i9Pz33bGGwEH0",
	"6X0L6AFb46wSAKHXhraUKAMN4m4MZ6E04LeXhSw/Owlzrfs+D3W3tR0mVBkUQkxYmVUckFdFXCLPWRzm",
	"abw5PKc6HPfAuIQ1paunkOs2vcO9fE8STXW+990Nl7WrsLMVWJ1UiLJ8nkWB9Z0qzVJq9LqX57+QHOND",
	"pSk3DV7n65ZIp14SEbao4WpFrZiy6OoT93i9titdpJyxBIWUJ/Yyrpt9kUnSIQyDPp/zkqa6lp7gbj2O",
	"7LIhDm/rbsLGjB8myE6opkbcbCSz0ZMG69lMLcazPJB9ElNNB8nouDrKtDf0UMB937vmOx29ZjouqVoZ",
	"cO0VmhYaeBeTlMmy1p/vmk+Hei39UiTQMhVon2Po8pRkdJsIatjUGFlGQvFlQUGXYickSdgCom2UuFQi",
	"dVdqFoHiklnMKoKnOYTjzq/rU2rl7JitEEyvHyQaCkFqgTNFrrDj1ahry5r5B04BG0Wzn70rAlEQrXJ+",
	"U52wy3gs8iiHbWJ7/wVkOMHQWLpqNezYKC+5+F5dh0avKcPioH7P1EX1RlnbuNrjkCtn62tqHDbZhvDA",
	"w7c6z/edOGd8WeT7nKUZjfZWVbCTTZb3ixFVTzgmIaGfvrXdrmEhJMyLjvNFKJD5qgBAbIcg2lqHp/Xz",
	"7AHcXjcoYRfu+hB0hsveWQ3CO2KdK57xCirIQw5Ld7UAKFckhqWkcbP6yi4nbeu64p5pWuvlHKWZQU1C",
	"l/Oad6JcaKVkSIGajvskRvUJ1clok4apmzkehPPUxa7bnluDK4wbzVnBl4Oubzb52QNT84hmOpe11LTK",
	"9H1SXpnbF9SWhKxUA7FVSQZRy4dmDgvU2rywMsAzGhq8sx0H3ZTrCONYCIddVbuMJABXK6EvYOncyJ8h",
	"IvmjXU5xsXHpjPz9F/crLmsfQAPvr1tYDxTRIpsksDBHsuQg73KTfQ+YweQej4WxR+z7HpIdEjGQBaF3",
	"VmlrMkYX+4jh/olm3lGi6fx2d+DiRyHZB8ExTIZjEZqKnOspOfcVeuzviuBlljEp5Lb/3dBh2pFhbGbQ",
	"cwnyn2bG0YDxY7HhgeHzLDz4XZLbLOzPmt5GtTlfI7xF7Qqc1Ifaf1PsDXJwwtslYNLqOciU2bplh7Hg",
	"Uoo8kOH5M2wIfnJXCST5R803s++dlcCt/u+ePj3a7xK/2PBQQMDMFT9hCMDP95eO+Q6537BZCYWeD49b",
	"G/ezISZUleJDL9jvuG+CNSVfqV+pjj5riYCifgPa9gb6NHwxLcqlMrpkb1SnuLfi4JGib7IdkCTWmaOI",
	"GLhjoQFUkcK5PBel4eUbocqbGQZdg5Qsxmw/rBXrMHBUvcr4uOcm4zhY5qAI9gY8kxUzwZYf/EzlDnDS",
	"PuR9xi+7qnv5gEw5j2pAwl9+3o2dnQhJ6S3eo2If4Iy/+aF7Bphir9ztrzc/DKTIo+Pj+vXSgbk6wfqt",
	"+5bLwbvtIKvZKwaDXemxmBAxV2XOyk6/fTW/xYgtm5XSzrcqa9TUE1hsqNVTUw29m1BNYgqcobbUZKVW",
	"LgTjW+9aWT3WExXVcWZz02hsc3EGZv5capHdVUYIGYGB0y/qztIUYkY1JGaSIkO0ilyTpaQRLPKEqFWu",
	"jeIzJe9WTJEUkwXRd8k4xuz9RS+bOmn4PBzx3qdEihW+ZkL3WB+lUqZ4T8NdRqugSmbM76LkXKfpapms",
	"ZrdWGgkVLivQmv67bQbv4FYfrJvfrTiI0Vy1FDegejOFNNyGHHFwiztEY4E26yVdCcx5SbNcV22qrsuQ",
	"Bm7ooA3XgNpX/qWZhBVwc+77fOzSp9auB2slQMJsNn3Dzda4J7BLRDXqV6MDKIZoQNXvSmm0utvIXunp",
	"8hkVV4LmHQEjt/iyYVOe1XcAhqZ2ep+sZ+kuNSQrvqlFP0pb9ykLX9OgnpVeLIJ5P8LOXp4Owpa9ZDgA",
	"AfV7lXcqycvtXZe+fo37NGhZYFJ87wlbuwthk6q9x6zXf9j00AUEn/mJOZmNJUDwsq7kkJCzFGuovjg/",
	"G41Ha5DKUuN4+mh67OqCcpqx0fPRk+nx9Im7R40rmvmU79kioUtvbUQBc+MNyCVg+ja2tHoI3DKlrd8d",
	"1JjkWWyU7wbQQNL4mlGi8gzkmikh4/EVpzwmWOMk55olKBSL1iewfidEosjVKGFKA2d8eTXCW4oJ40CY",
	"IuIatcm49NPrXGIpW3/JBfMBi1qnZzFeQdHRyo/yCtdvBS0o/YOIt3u9INFQRTw2G8LVL8niUAuSIlpd",
	"8Yffr0aTyQ0T6sbmR04mMVP0OoHJMsuvRu+PDk9ptBN6H2Srsp2WOVjWLd81eXx8HHAE4PwtvWOseFMs",
	"zRG7WQLk03j01EIKbYVixFnzGZVP49GzIf3qb5DggxxeJR/9YvmymGJCcx6tHBHM5N2csVvJvXmWCBpP",
	"4Fab01BwNaE8nvi2hubB6zm/YDezJYzalhp2LECQDywjRo9ia7Nh4FZjSVi9gpTk3Oh/s5VIYXaDO3tW",
	"Dj27yo+Pn0ScpoB/wfiKK8CKzaiHlyPYVTF+wDYkfhde8T9xG1p8nRZLfcHjC4fjXdsxzRPNMir1bCFk",
	"Oompprt2ZInK7rzpso3Zmpb8iBOMxtnDrNh/dfDh2xWvRGJois4rLUiW0AhctR1Prv2o3tD+X0x+o5MP",
	"x5Pvp/PJ+4+Pxo+fPQv72D6wbG5MlPYUfysZ0ttxhl7UzAyPvsrWLmf9MM2VLnK+U8rZApSeGrF4VI0k",
	"XzNutmCfRltMz11TCSm3O8VbhbqHybhHoWyGghssK0A8Dog5u2uKzcGUtX2/sMBriaCCmhUmf0iVEUjq",
	"qCoEiyU6aeiskpktNp2K3N4U8bKvvpfLYtp3OEp3avutat2HHmG26KQtjF1WPv+iZLtkaZ5ggIEgnmvF",
	"u8O2Yp1GsaTLNomaaXCYXs9jG3zxQ9mil2MinFsz2Vp9zF1cWwmpbdnDsZkFbxbCXLI12Bv0jpcSoAqm",
	"V/xdrQZXT/nJ0PFQ1By9J45q1TQ9lKEMoK+EkXAqtlgEMjmSiSIdGhxjyNi3qYtiF/dEgVYxjbttaVd5",
	"wqzsy1Lhja+FkVbn5dI83ZsnEFc2gRqyx/E21/wGtj1b3F1cLsfBmCtuZ17s8sKTPCU/mc/lzbDKHbIr",
	"HroZNiWvUDRENYdR0r6CNiYK4IqbyYSvkRGqiS9/GS2Zni4kQAzqRotsKuRydmv+L5NCi9nto0f2jyyh",
	"jM8ssBgW05UVNS6osBJcSFX14LkiF4XnnOTKhYwihwqVAGTKKWSWCiIO2o3uXuM9bYfmtclDdwMSFLnl",
	"a7LF7PFT1UyQLwcwvioSN7pF1Tt6A2WCxz0RqJ2n8snRqE2SyoAspUuYZTZ5sxypX1du3eYqJ0AQ6Bcl",
	"6Eub2maUhHJaLqrRQ06RJN1CzGbgkLXLUkm2RrGYCbO3feaM+U1X1I+KJK0rMphfadQdDORVk1CchlJL",
	"gbF5AYwb0xYTZDSLbpStAm3Ts6zCXOEgcg0rumaGpemWrKnc/p3oHC0pV8Pdb+DpFcfnH6+FXlWWggD9",
	"Wgnm79hpZFKsGZoeuhRvOLIV8Km7QawZLvVhAQO1tHKAI+tju6Y6WoEimxVA4rLRnSj8byfYndY5mbhH",
	"VX4mkwlqfuSYWHvU6orWIv3vkIS89Ikw97T9KqlZh0pHx15fieJvJ1PqCpY8VBulzT0fM0RE+qKcHcLR",
	"Rc7uiS7NwNyhlLEBsm32NZ1a+JqSNhPrpkIM61n5aNnzjyNXPzJ0RxQ849Uf+VWBvXSR8x8qT6FlVNIU",
	"NIa1fv8Yuv89UWAa6Uq1/3K9Nt3Jx/AeRnE2ti/NjItckTFNEkzhYgbkHzngoWQdXNUHsMcVvihvVtJq",
	"AlxxhL3vPR0P57vWa8uht7KbYcsvyk0XOe+gv+MkW76mFo0JhC5clZv7UkMDVZ2Gb+nPY5rXXnIJkPUX",
	"F4Dwr5pE2NIXDrkDiZ8ef9/fr/7i+mcMVHQsx7DGQs3sG0bzogQBskkecsbV33m6L49c+DWpQ72uZVqj",
	"XedXdAjYlRKKUdAS/Z4u9mGjAXSxLy/dN13aD1Md7NgqSGKXGN9tZz3t71d/yP+zeMRw5tXq6026+fDI",
	"DpK9siGKr5tamKP9H0AopEdBI7HhiaCx2V3zDyzrVK9s8SFFKPnt7Nxmn1aiWrYqC5JLFYWtCgdZreB9",
	"g/5u/BMmf2NZnxq24wE6H2oztphfVJeu5TLL6zxQ1bp6M9X3U7scXu/kmjBY92ssUhuRsaoI/hb50hGr",
	"KkII9Yzmllzwq2G8uU/XcYxa56iiWvhQXup9ouFrYKH9hF5ZMb3NSCjGqq+Wfnss8w/QtYLyvp5Ki3oF",
	"2xh7DQ8i1ck3ZV37w4TQt8kp5aoDrFLqJ4lNR/sGeQVTUJDyNr+8zRtY971LP/GF0u8xQvc5dBOMiJX6",
	"/DdIJ1wBltjFpJ5dm1kCjQutMriXL4DGTqcctpVxMK9KGPhfy24WkQY9Kat43EmHeGWrIdDPZ/p9IWYx",
	"9C11UHSaeeZQYAX9vHIdsXN3t2+F3pdrvfP66aE7vgLKp4t+g4S8BB14LKZCuhneVFUrlhUUtjlj3fGt",
	"F0kiNj61DFMkbXFoIYlNbUzAHQguY0BCKpwMsM+TTTtSKb168NlyJwuNpCP58ZCHNip1r5xCO+zpDS9Q",
	"900xdOmFu1/T2J1CjVj4bOmFSKUis/BbF3WBjMOF09eq28Hb7jszpylmSeN+s9U4bZI006o03ltZNKGH",
	"XEKbw5rvn21r7Mv6cfXWdiX9uzCatRi2D6oZvXdIt921Hw5k7N9YVrJ1hYD/MUxOq1n8DRYt+H3jAzfh",
	"WGy1KsB9HeaBwgPDaXrgxRdcdrCg5y+c/ZFD6LZ8uSc2Dh2910DbSiMuk3zuqydfiNHsYqqeJoMrW6NC",
	"1Vls9tGj/JO73wr2al6T30RWslvD2kALwpkMzoAo6LjLiOi3GQL1DD2hsNbVt06oS7w7blaElyYCVmCT",
	"SDObc9NpE9p6lK/U6doF2f80WjXtOw232s42aNj1Ofaqb+yGctguTytlHUul1uUkYaUoGrvbu/+aXF6e",
	"Tl7auU3eBZ+efQMxo+5W9YIY8Fgn0qU4PWwKsaNa/oIvItkSdYEqkp++RTZFRLew7LL7rdgtOBbL4+0M",
	"h/1qmgzxXJxUVB/a8mLcn/di3FmtZVGUMOqsXuSfJkIt87unT7umiSV/Oqa1s+aR3XxDTvw7+lUONEt8",
	"Kd1v/hhF+9KcnD5yXwYVE7FUsxKxYV+7WLr6wB1yuMEQ9s3HnZzrBY1/xry4fRmsVxseZiGSRGzC+Ve1",
	"Iq2VSk1NMguebIucVMIW/r1Kpoib2o6N2X2q7DNOZe3h0coGc1fnePTFTrTiAd/eo8ww1ld9eoVOBjNp",
	"ItYgzdB2g2QJ3W6w9ODMPVXTbbj7pEYqseKH3JLzorerFc/N7sO39spXQpA0t5rQJWVcWTv4WoqNAklc",
	"UfYrLjhJRESTlVD6+fePHz+ekncYxo8BS85TFFFGVD/I6BIejMkDB/eBvZr5wIF8UL584rK+ZVGMXHuI",
	"5eTwIqfOJT4+wP0rf/bdzUCapkNBue6X9nS4D8uuNdYXys8LzMNWmGrvkZclcr+mlC7PuOUSMI35Emdu",
	"OSLAnG6DWJmEu6Pb0K+81HFv94Xab4H8uXzQfo8nwAHl4ziyqEP2xene8fhWncD4/kkvhfHNlfslce2t",
	"mC9D4+rLMqGj0D4V85XRlu4g7sfyEZpPsxtWv5EUJPRPDFPc++3yyvM2u1TCnrdrhhsLBxG0+gzTn8xS",
	"laewA6z09qdvMlBoREnxjpRXW7s5ThXPAgUtkPrjQX82092zKLGLCkkR9+WbzPiqvN9jl9dN+pgNOFaw",
	"1X+MuKm9lvSFjrDK40Whq0LVx4S+WadHKXzs60q7+VDkus8XUiJP5HqnU+QLyaM7GPeBp6B6zfzGI09G",
	"zWi+8vT/fdj34MOucLXIdcNnUT58X8bBwtLVXjMo3ym6z1sdrbLG3eUCuiqb/wfc58gkrBkq4L7YcbV2",
	"cot+Lt2+Ux75fPwqCXeGIooIQFFquQxFTwneyXcvg9eu2ue+kIpzsRbdu6ICKL7CMYG+Ys39Qg4RNkuz",
	"p3dOsqxUzbdxnJqoKr5OXrnHzCYvdj4qJhblm2/tl9Cm5B85lZRrgNg9uHDx6uWTJ0++n+52J9emcmmD",
	"+wfNxD/keeBEzFQeHz/etUWZkUksSfARHymWEpQakwzrYBEtt9aRRBJqSzxX0H0BWm4nLxY69AzGZb5c",
	"2tszWI6r8bBypdCi3NpNUC5iVwn/b/EEKK7g2DoJCvcicD1MoiTMngOdtyr8U4A2dfIOOuigivy1hwfb",
	"qYet/eprVMpilp/t2gFNkirYOtpaxU4DeUz3fYyGHxAJnqKPdm1R/2bft3cxHDFQlNgp5dqUvOXJFtMu",
	"S1mXgSRnJySi3BaeWTKlQUJs64kYCTJtU1lku4hceZvh3mgceP9hf0XJ5RV92WouWmT14wcX8v8CAAD/",
	"/1tkcF0+vgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
